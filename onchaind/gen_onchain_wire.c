/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <onchaind/gen_onchain_wire.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *onchain_wire_type_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum onchain_wire_type)e) {
	case WIRE_ONCHAIN_INIT: return "WIRE_ONCHAIN_INIT";
	case WIRE_ONCHAIN_HTLC_TIMEOUT: return "WIRE_ONCHAIN_HTLC_TIMEOUT";
	case WIRE_ONCHAIN_DEV_MEMLEAK: return "WIRE_ONCHAIN_DEV_MEMLEAK";
	case WIRE_ONCHAIN_ADD_UTXO: return "WIRE_ONCHAIN_ADD_UTXO";
	case WIRE_ONCHAIN_ANNOTATE_TXOUT: return "WIRE_ONCHAIN_ANNOTATE_TXOUT";
	case WIRE_ONCHAIN_BROADCAST_TX: return "WIRE_ONCHAIN_BROADCAST_TX";
	case WIRE_ONCHAIN_ANNOTATE_TXIN: return "WIRE_ONCHAIN_ANNOTATE_TXIN";
	case WIRE_ONCHAIN_INIT_REPLY: return "WIRE_ONCHAIN_INIT_REPLY";
	case WIRE_ONCHAIN_DEPTH: return "WIRE_ONCHAIN_DEPTH";
	case WIRE_ONCHAIN_UNWATCH_TX: return "WIRE_ONCHAIN_UNWATCH_TX";
	case WIRE_ONCHAIN_SPENT: return "WIRE_ONCHAIN_SPENT";
	case WIRE_ONCHAIN_MISSING_HTLC_OUTPUT: return "WIRE_ONCHAIN_MISSING_HTLC_OUTPUT";
	case WIRE_ONCHAIN_ALL_IRREVOCABLY_RESOLVED: return "WIRE_ONCHAIN_ALL_IRREVOCABLY_RESOLVED";
	case WIRE_ONCHAIN_DEV_MEMLEAK_REPLY: return "WIRE_ONCHAIN_DEV_MEMLEAK_REPLY";
	case WIRE_ONCHAIN_HTLC: return "WIRE_ONCHAIN_HTLC";
	case WIRE_ONCHAIN_EXTRACTED_PREIMAGE: return "WIRE_ONCHAIN_EXTRACTED_PREIMAGE";
	case WIRE_ONCHAIN_KNOWN_PREIMAGE: return "WIRE_ONCHAIN_KNOWN_PREIMAGE";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}




/* WIRE: ONCHAIN_INIT */
/* Begin!  Here's the onchain tx which spends funding tx */
u8 *towire_onchain_init(const tal_t *ctx, const struct shachain *shachain, const struct chainparams *chainparams, struct amount_sat funding_amount_satoshi, const struct pubkey *old_remote_per_commitment_point, const struct pubkey *remote_per_commitment_point, u32 local_to_self_delay, u32 remote_to_self_delay, u32 feerate_per_kw, struct amount_sat local_dust_limit_satoshi, const struct bitcoin_txid *our_broadcast_txid, const u8 *local_scriptpubkey, const u8 *remote_scriptpubkey, const struct pubkey *ourwallet_pubkey, enum side funder, const struct basepoints *local_basepoints, const struct basepoints *remote_basepoints, const struct bitcoin_tx *tx, u32 tx_blockheight, u32 reasonable_depth, const secp256k1_ecdsa_signature *htlc_signature, u64 num_htlcs, u32 min_possible_feerate, u32 max_possible_feerate, const struct pubkey *possible_remote_per_commit_point, bool option_static_remotekey)
{
	u16 num_htlc_sigs = tal_count(htlc_signature);
	u16 local_scriptpubkey_len = tal_count(local_scriptpubkey);
	u16 remote_scriptpubkey_len = tal_count(remote_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_INIT);
	towire_shachain(&p, shachain);
	/* This needs to be set explicitly since the same message also contains a */
	/* transaction that we need to parse correctly. */
	towire_chainparams(&p, chainparams);
	towire_amount_sat(&p, funding_amount_satoshi);
	/* Remote per commit point for committed tx. */
	towire_pubkey(&p, old_remote_per_commitment_point);
	/* Remote per commit point for current tx (needed if we haven't got revoke_and_ack yet). */
	towire_pubkey(&p, remote_per_commitment_point);
	towire_u32(&p, local_to_self_delay);
	towire_u32(&p, remote_to_self_delay);
	towire_u32(&p, feerate_per_kw);
	towire_amount_sat(&p, local_dust_limit_satoshi);
	/* Gives an easy way to tell if it's our unilateral close or theirs... */
	towire_bitcoin_txid(&p, our_broadcast_txid);
	towire_u16(&p, local_scriptpubkey_len);
	towire_u8_array(&p, local_scriptpubkey, local_scriptpubkey_len);
	towire_u16(&p, remote_scriptpubkey_len);
	towire_u8_array(&p, remote_scriptpubkey, remote_scriptpubkey_len);
	towire_pubkey(&p, ourwallet_pubkey);
	/* We need these two for commit number obscurer */
	towire_side(&p, funder);
	towire_basepoints(&p, local_basepoints);
	towire_basepoints(&p, remote_basepoints);
	towire_bitcoin_tx(&p, tx);
	towire_u32(&p, tx_blockheight);
	towire_u32(&p, reasonable_depth);
	towire_u16(&p, num_htlc_sigs);
	for (size_t i = 0; i < num_htlc_sigs; i++)
		towire_secp256k1_ecdsa_signature(&p, htlc_signature + i);
	towire_u64(&p, num_htlcs);
	towire_u32(&p, min_possible_feerate);
	towire_u32(&p, max_possible_feerate);
	if (!possible_remote_per_commit_point)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, possible_remote_per_commit_point);
	}
	towire_bool(&p, option_static_remotekey);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_init(const tal_t *ctx, const void *p, struct shachain *shachain, const struct chainparams **chainparams, struct amount_sat *funding_amount_satoshi, struct pubkey *old_remote_per_commitment_point, struct pubkey *remote_per_commitment_point, u32 *local_to_self_delay, u32 *remote_to_self_delay, u32 *feerate_per_kw, struct amount_sat *local_dust_limit_satoshi, struct bitcoin_txid *our_broadcast_txid, u8 **local_scriptpubkey, u8 **remote_scriptpubkey, struct pubkey *ourwallet_pubkey, enum side *funder, struct basepoints *local_basepoints, struct basepoints *remote_basepoints, struct bitcoin_tx **tx, u32 *tx_blockheight, u32 *reasonable_depth, secp256k1_ecdsa_signature **htlc_signature, u64 *num_htlcs, u32 *min_possible_feerate, u32 *max_possible_feerate, struct pubkey **possible_remote_per_commit_point, bool *option_static_remotekey)
{
	u16 num_htlc_sigs;
	u16 local_scriptpubkey_len;
	u16 remote_scriptpubkey_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_INIT)
		return false;
 	fromwire_shachain(&cursor, &plen, shachain);
 	/* This needs to be set explicitly since the same message also contains a */
	/* transaction that we need to parse correctly. */
	fromwire_chainparams(&cursor, &plen, chainparams);
 	*funding_amount_satoshi = fromwire_amount_sat(&cursor, &plen);
 	/* Remote per commit point for committed tx. */
	fromwire_pubkey(&cursor, &plen, old_remote_per_commitment_point);
 	/* Remote per commit point for current tx (needed if we haven't got revoke_and_ack yet). */
	fromwire_pubkey(&cursor, &plen, remote_per_commitment_point);
 	*local_to_self_delay = fromwire_u32(&cursor, &plen);
 	*remote_to_self_delay = fromwire_u32(&cursor, &plen);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
 	*local_dust_limit_satoshi = fromwire_amount_sat(&cursor, &plen);
 	/* Gives an easy way to tell if it's our unilateral close or theirs... */
	fromwire_bitcoin_txid(&cursor, &plen, our_broadcast_txid);
 	local_scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case local_scriptpubkey
	*local_scriptpubkey = local_scriptpubkey_len ? tal_arr(ctx, u8, local_scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *local_scriptpubkey, local_scriptpubkey_len);
 	remote_scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case remote_scriptpubkey
	*remote_scriptpubkey = remote_scriptpubkey_len ? tal_arr(ctx, u8, remote_scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *remote_scriptpubkey, remote_scriptpubkey_len);
 	fromwire_pubkey(&cursor, &plen, ourwallet_pubkey);
 	/* We need these two for commit number obscurer */
	*funder = fromwire_side(&cursor, &plen);
 	fromwire_basepoints(&cursor, &plen, local_basepoints);
 	fromwire_basepoints(&cursor, &plen, remote_basepoints);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	*tx_blockheight = fromwire_u32(&cursor, &plen);
 	*reasonable_depth = fromwire_u32(&cursor, &plen);
 	num_htlc_sigs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_signature
	*htlc_signature = num_htlc_sigs ? tal_arr(ctx, secp256k1_ecdsa_signature, num_htlc_sigs) : NULL;
	for (size_t i = 0; i < num_htlc_sigs; i++)
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *htlc_signature + i);
 	*num_htlcs = fromwire_u64(&cursor, &plen);
 	*min_possible_feerate = fromwire_u32(&cursor, &plen);
 	*max_possible_feerate = fromwire_u32(&cursor, &plen);
 	if (!fromwire_bool(&cursor, &plen))
		*possible_remote_per_commit_point = NULL;
	else {
		*possible_remote_per_commit_point = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *possible_remote_per_commit_point);
	}
 	*option_static_remotekey = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_HTLC_TIMEOUT */
/* onchaind->master: this HTLC has timed out (after reasonable_depth) */
u8 *towire_onchain_htlc_timeout(const tal_t *ctx, const struct htlc_stub *htlc)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_HTLC_TIMEOUT);
	towire_htlc_stub(&p, htlc);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_htlc_timeout(const void *p, struct htlc_stub *htlc)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_HTLC_TIMEOUT)
		return false;
 	fromwire_htlc_stub(&cursor, &plen, htlc);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_DEV_MEMLEAK */
/* master -> onchaind: do you have a memleak? */
u8 *towire_onchain_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: ONCHAIN_ADD_UTXO */
/* onchaind->master: hey */
u8 *towire_onchain_add_utxo(const tal_t *ctx, const struct bitcoin_txid *prev_out_tx, u32 prev_out_index, const struct pubkey *per_commit_point, struct amount_sat value, u32 blockheight, const u8 *scriptpubkey)
{
	u16 len = tal_count(scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_ADD_UTXO);
	towire_bitcoin_txid(&p, prev_out_tx);
	towire_u32(&p, prev_out_index);
	if (!per_commit_point)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, per_commit_point);
	}
	towire_amount_sat(&p, value);
	towire_u32(&p, blockheight);
	towire_u16(&p, len);
	towire_u8_array(&p, scriptpubkey, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_add_utxo(const tal_t *ctx, const void *p, struct bitcoin_txid *prev_out_tx, u32 *prev_out_index, struct pubkey **per_commit_point, struct amount_sat *value, u32 *blockheight, u8 **scriptpubkey)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_ADD_UTXO)
		return false;
 	fromwire_bitcoin_txid(&cursor, &plen, prev_out_tx);
 	*prev_out_index = fromwire_u32(&cursor, &plen);
 	if (!fromwire_bool(&cursor, &plen))
		*per_commit_point = NULL;
	else {
		*per_commit_point = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *per_commit_point);
	}
 	*value = fromwire_amount_sat(&cursor, &plen);
 	*blockheight = fromwire_u32(&cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case scriptpubkey
	*scriptpubkey = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *scriptpubkey, len);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_ANNOTATE_TXOUT */
/* Tell the main daemon what we've been watching */
/* that we tracked automatically but only onchaind knows how to classify their */
/* transactions. */
u8 *towire_onchain_annotate_txout(const tal_t *ctx, const struct bitcoin_txid *txid, u32 outnum, enum wallet_tx_type type)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_ANNOTATE_TXOUT);
	towire_bitcoin_txid(&p, txid);
	towire_u32(&p, outnum);
	towire_wallet_tx_type(&p, type);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_annotate_txout(const void *p, struct bitcoin_txid *txid, u32 *outnum, enum wallet_tx_type *type)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_ANNOTATE_TXOUT)
		return false;
 	fromwire_bitcoin_txid(&cursor, &plen, txid);
 	*outnum = fromwire_u32(&cursor, &plen);
 	*type = fromwire_wallet_tx_type(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_BROADCAST_TX */
/* onchaind->master: Send out a tx. */
u8 *towire_onchain_broadcast_tx(const tal_t *ctx, const struct bitcoin_tx *tx, enum wallet_tx_type type)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_BROADCAST_TX);
	towire_bitcoin_tx(&p, tx);
	towire_wallet_tx_type(&p, type);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_broadcast_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, enum wallet_tx_type *type)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_BROADCAST_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	*type = fromwire_wallet_tx_type(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_ANNOTATE_TXIN */
u8 *towire_onchain_annotate_txin(const tal_t *ctx, const struct bitcoin_txid *txid, u32 innum, enum wallet_tx_type type)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_ANNOTATE_TXIN);
	towire_bitcoin_txid(&p, txid);
	towire_u32(&p, innum);
	towire_wallet_tx_type(&p, type);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_annotate_txin(const void *p, struct bitcoin_txid *txid, u32 *innum, enum wallet_tx_type *type)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_ANNOTATE_TXIN)
		return false;
 	fromwire_bitcoin_txid(&cursor, &plen, txid);
 	*innum = fromwire_u32(&cursor, &plen);
 	*type = fromwire_wallet_tx_type(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_INIT_REPLY */
/* This says we're ready; give us preimages. */
u8 *towire_onchain_init_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_INIT_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_init_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_INIT_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: ONCHAIN_DEPTH */
/* master->onchaind: We will receive more than one of these */
u8 *towire_onchain_depth(const tal_t *ctx, const struct bitcoin_txid *txid, u32 depth)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_DEPTH);
	towire_bitcoin_txid(&p, txid);
	towire_u32(&p, depth);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_depth(const void *p, struct bitcoin_txid *txid, u32 *depth)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_DEPTH)
		return false;
 	fromwire_bitcoin_txid(&cursor, &plen, txid);
 	*depth = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_UNWATCH_TX */
/* onchaind->master: We don't want to watch this tx */
u8 *towire_onchain_unwatch_tx(const tal_t *ctx, const struct bitcoin_txid *txid)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_UNWATCH_TX);
	towire_bitcoin_txid(&p, txid);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_unwatch_tx(const void *p, struct bitcoin_txid *txid)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_UNWATCH_TX)
		return false;
 	fromwire_bitcoin_txid(&cursor, &plen, txid);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_SPENT */
/* master->onchaind: Notifier that an output has been spent by input_num of tx. */
u8 *towire_onchain_spent(const tal_t *ctx, const struct bitcoin_tx *tx, u32 input_num, u32 blockheight)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_SPENT);
	towire_bitcoin_tx(&p, tx);
	towire_u32(&p, input_num);
	towire_u32(&p, blockheight);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_spent(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, u32 *input_num, u32 *blockheight)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_SPENT)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	*input_num = fromwire_u32(&cursor, &plen);
 	*blockheight = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_MISSING_HTLC_OUTPUT */
/* onchaind->master: this HTLC was missing from commit tx. */
u8 *towire_onchain_missing_htlc_output(const tal_t *ctx, const struct htlc_stub *htlc)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_MISSING_HTLC_OUTPUT);
	towire_htlc_stub(&p, htlc);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_missing_htlc_output(const void *p, struct htlc_stub *htlc)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_MISSING_HTLC_OUTPUT)
		return false;
 	fromwire_htlc_stub(&cursor, &plen, htlc);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_ALL_IRREVOCABLY_RESOLVED */
/* onchaind->master: this peer can be forgotten */
u8 *towire_onchain_all_irrevocably_resolved(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_ALL_IRREVOCABLY_RESOLVED);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_all_irrevocably_resolved(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_ALL_IRREVOCABLY_RESOLVED)
		return false;
	return cursor != NULL;
}

/* WIRE: ONCHAIN_DEV_MEMLEAK_REPLY */
u8 *towire_onchain_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_HTLC */
/* This is all the HTLCs: one per message */
u8 *towire_onchain_htlc(const tal_t *ctx, const struct htlc_stub *htlc, bool tell_if_missing, bool tell_immediately)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_HTLC);
	towire_htlc_stub(&p, htlc);
	/* If it's not in the commitment tx */
	towire_bool(&p, tell_if_missing);
	towire_bool(&p, tell_immediately);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_htlc(const void *p, struct htlc_stub *htlc, bool *tell_if_missing, bool *tell_immediately)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_HTLC)
		return false;
 	fromwire_htlc_stub(&cursor, &plen, htlc);
 	/* If it's not in the commitment tx */
	*tell_if_missing = fromwire_bool(&cursor, &plen);
 	*tell_immediately = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_EXTRACTED_PREIMAGE */
/* onchaind->master: We discovered HTLC preimage */
u8 *towire_onchain_extracted_preimage(const tal_t *ctx, const struct preimage *preimage)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_EXTRACTED_PREIMAGE);
	towire_preimage(&p, preimage);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_extracted_preimage(const void *p, struct preimage *preimage)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_EXTRACTED_PREIMAGE)
		return false;
 	fromwire_preimage(&cursor, &plen, preimage);
	return cursor != NULL;
}

/* WIRE: ONCHAIN_KNOWN_PREIMAGE */
/* master->onchaind: We know HTLC preimage */
u8 *towire_onchain_known_preimage(const tal_t *ctx, const struct preimage *preimage)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONCHAIN_KNOWN_PREIMAGE);
	towire_preimage(&p, preimage);

	return memcheck(p, tal_count(p));
}
bool fromwire_onchain_known_preimage(const void *p, struct preimage *preimage)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONCHAIN_KNOWN_PREIMAGE)
		return false;
 	fromwire_preimage(&cursor, &plen, preimage);
	return cursor != NULL;
}

