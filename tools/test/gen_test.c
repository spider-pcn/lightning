/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <tools/test/gen_test.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif

/* AUTOGENERATED MOCKS START */
/* Generated stub for fromwire_amount_msat */
struct amount_msat fromwire_amount_msat(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_amount_msat called!\n"); abort(); }
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_bool */
bool fromwire_bool(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bool called!\n"); abort(); }
/* Generated stub for fromwire_fail */
const void *fromwire_fail(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_fail called!\n"); abort(); }
/* Could not find declaration for fromwire_test_enum */
/* Generated stub for fromwire_tu32 */
u32 fromwire_tu32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_tu32 called!\n"); abort(); }
/* Generated stub for fromwire_tu64 */
u64 fromwire_tu64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_tu64 called!\n"); abort(); }
/* Generated stub for fromwire_u16 */
u16 fromwire_u16(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u16 called!\n"); abort(); }
/* Generated stub for fromwire_u32 */
u32 fromwire_u32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u32 called!\n"); abort(); }
/* Generated stub for fromwire_u64 */
u64 fromwire_u64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u64 called!\n"); abort(); }
/* Generated stub for fromwire_u8 */
u8 fromwire_u8(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u8 called!\n"); abort(); }
/* Generated stub for fromwire_u8_array */
void fromwire_u8_array(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_u8_array called!\n"); abort(); }
/* Could not find declaration for main */
/* Could not find declaration for tal_alloc_ */
/* Could not find declaration for tal_alloc_arr_ */
/* Could not find declaration for tal_bytelen */
/* Could not find declaration for tal_dup_ */
/* Could not find declaration for tal_free */
/* Could not find declaration for tal_resize_ */
/* Generated stub for towire */
void towire(u8 **pptr UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "towire called!\n"); abort(); }
/* Generated stub for towire_amount_msat */
void towire_amount_msat(u8 **pptr UNNEEDED, const struct amount_msat msat UNNEEDED)
{ fprintf(stderr, "towire_amount_msat called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_bool */
void towire_bool(u8 **pptr UNNEEDED, bool v UNNEEDED)
{ fprintf(stderr, "towire_bool called!\n"); abort(); }
/* Could not find declaration for towire_test_enum */
/* Generated stub for towire_tu32 */
void towire_tu32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
{ fprintf(stderr, "towire_tu32 called!\n"); abort(); }
/* Generated stub for towire_tu64 */
void towire_tu64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
{ fprintf(stderr, "towire_tu64 called!\n"); abort(); }
/* Generated stub for towire_u16 */
void towire_u16(u8 **pptr UNNEEDED, u16 v UNNEEDED)
{ fprintf(stderr, "towire_u16 called!\n"); abort(); }
/* Generated stub for towire_u32 */
void towire_u32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
{ fprintf(stderr, "towire_u32 called!\n"); abort(); }
/* Generated stub for towire_u64 */
void towire_u64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
{ fprintf(stderr, "towire_u64 called!\n"); abort(); }
/* Generated stub for towire_u8 */
void towire_u8(u8 **pptr UNNEEDED, u8 v UNNEEDED)
{ fprintf(stderr, "towire_u8 called!\n"); abort(); }
/* Generated stub for towire_u8_array */
void towire_u8_array(u8 **pptr UNNEEDED, const u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "towire_u8_array called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */
/* variable length set of assignables (helper) */

const char *test_type_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum test_type)e) {
	case WIRE_TEST_MSG: return "WIRE_TEST_MSG";
	case WIRE_TEST_TLV3: return "WIRE_TEST_TLV3";
	case WIRE_TEST_TLV1: return "WIRE_TEST_TLV1";
	case WIRE_TEST_IFDEF: return "WIRE_TEST_IFDEF";
	case WIRE_TEST_TLV2: return "WIRE_TEST_TLV2";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}



/* SUBTYPE: TEST_SHORT_ID */
/* normal struct */
static void towire_test_short_id(u8 **p, const struct test_short_id *test_short_id)
{

	towire_u64(p, test_short_id->u64);
}
static void fromwire_test_short_id(const u8 **cursor, size_t *plen, struct test_short_id *test_short_id)
{

 	test_short_id->u64 = fromwire_u64(cursor, plen);
}

/* SUBTYPE: TEST_FEATURES */
/* var-sized struct */
static void towire_test_features(u8 **p, const struct test_features *test_features)
{
	u16 len_gf = tal_count(test_features->globalfeatures);
	u16 len_lf = tal_count(test_features->localfeatures);

	towire_u16(p, len_lf);
	towire_u8_array(p, test_features->localfeatures, len_lf);
	towire_u16(p, len_gf);
	towire_u8_array(p, test_features->globalfeatures, len_gf);
}
static struct test_features *
fromwire_test_features(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct test_features *test_features = tal(ctx, struct test_features);
	u16 len_gf;
	u16 len_lf;

 	len_lf = fromwire_u16(cursor, plen);
 	test_features->localfeatures = len_lf ? tal_arr(test_features, u8, len_lf) : NULL;
fromwire_u8_array(cursor, plen, test_features->localfeatures, len_lf);
 	len_gf = fromwire_u16(cursor, plen);
 	test_features->globalfeatures = len_gf ? tal_arr(test_features, u8, len_gf) : NULL;
fromwire_u8_array(cursor, plen, test_features->globalfeatures, len_gf);

	return test_features;
}

/* SUBTYPE: SUBTYPE_VAR_ASSIGN */
/* A subtype to test varsize things of */
/* - A two level subtype comment */
static void towire_subtype_var_assign(u8 **p, const struct subtype_var_assign *subtype_var_assign)
{
	u8 len_1 = tal_count(subtype_var_assign->field_1);

	/* variable length set of assignables (helper) */
	towire_u8(p, len_1);
		for (size_t i = 0; i < len_1; i++)
		towire_u16(p, subtype_var_assign->field_1[i]);
}
static struct subtype_var_assign *
fromwire_subtype_var_assign(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct subtype_var_assign *subtype_var_assign = tal(ctx, struct subtype_var_assign);
	u8 len_1;

	/* variable length set of assignables (helper) */
 	len_1 = fromwire_u8(cursor, plen);
 	subtype_var_assign->field_1 = len_1 ? tal_arr(subtype_var_assign, u16, 0) : NULL;
	for (size_t i = 0; i < len_1; i++) {
		u16 tmp;
		tmp = fromwire_u16(cursor, plen);
		tal_arr_expand(&subtype_var_assign->field_1, tmp);
	}

	return subtype_var_assign;
}

/* SUBTYPE: SUBTYPE_VARSIZE_STRUCT */
/* subtype with a nested varsize size struct */
static void towire_subtype_varsize_struct(u8 **p, const struct subtype_varsize_struct *subtype_varsize_struct)
{

	towire_test_features(p, &subtype_varsize_struct->field_0);
}
static void fromwire_subtype_varsize_struct(const u8 **cursor, size_t *plen, struct subtype_varsize_struct *subtype_varsize_struct)
{

 	subtype_varsize_struct->field_0 = *fromwire_test_features(subtype_varsize_struct, cursor, plen);
}

/* SUBTYPE: SUBTYPE_VAR_LEN */
/* variable length set of structs */
static void towire_subtype_var_len(u8 **p, const struct subtype_var_len *subtype_var_len)
{
	u8 len_2 = tal_count(subtype_var_len->field_2);

	towire_u8(p, len_2);
		for (size_t i = 0; i < len_2; i++)
		towire_test_short_id(p, subtype_var_len->field_2 + i);
}
static struct subtype_var_len *
fromwire_subtype_var_len(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct subtype_var_len *subtype_var_len = tal(ctx, struct subtype_var_len);
	u8 len_2;

 	len_2 = fromwire_u8(cursor, plen);
 	subtype_var_len->field_2 = len_2 ? tal_arr(subtype_var_len, struct test_short_id, 0) : NULL;
	for (size_t i = 0; i < len_2; i++) {
		struct test_short_id tmp;
		fromwire_test_short_id(cursor, plen, &tmp);
		tal_arr_expand(&subtype_var_len->field_2, tmp);
	}

	return subtype_var_len;
}

/* SUBTYPE: SUBTYPE_NESTED */
/* A subtype with a nested subtype */
static void towire_subtype_nested(u8 **p, const struct subtype_nested *subtype_nested)
{

	towire_test_short_id(p, &subtype_nested->field_1);
}
static void fromwire_subtype_nested(const u8 **cursor, size_t *plen, struct subtype_nested *subtype_nested)
{

 	fromwire_test_short_id(cursor, plen, &subtype_nested->field_1);
}

/* SUBTYPE: SUBTYPE_VARLEN_VARSIZE */
static void towire_subtype_varlen_varsize(u8 **p, const struct subtype_varlen_varsize *subtype_varlen_varsize)
{
	u8 len = tal_count(subtype_varlen_varsize->field_1);

	/* variable length set of variable size structs */
	towire_u8(p, len);
		for (size_t i = 0; i < len; i++)
		towire_test_features(p, subtype_varlen_varsize->field_1[i]);
}
static struct subtype_varlen_varsize *
fromwire_subtype_varlen_varsize(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct subtype_varlen_varsize *subtype_varlen_varsize = tal(ctx, struct subtype_varlen_varsize);
	u8 len;

	/* variable length set of variable size structs */
 	len = fromwire_u8(cursor, plen);
 	subtype_varlen_varsize->field_1 = len ? tal_arr(subtype_varlen_varsize, struct test_features *, 0) : NULL;
	for (size_t i = 0; i < len; i++) {
		struct test_features * tmp;
		tmp = fromwire_test_features(subtype_varlen_varsize, cursor, plen);
		tal_arr_expand(&subtype_varlen_varsize->field_1, tmp);
	}

	return subtype_varlen_varsize;
}

/* SUBTYPE: SUBTYPE_ARRAYS */
/* Subtype to test arrays of things */
static void towire_subtype_arrays(u8 **p, const struct subtype_arrays *subtype_arrays)
{

	towire_u8_array(p, subtype_arrays->field1, 2);
		for (size_t i = 0; i < 2; i++)
		towire_u16(p, subtype_arrays->field2[i]);
		for (size_t i = 0; i < 2; i++)
		towire_test_short_id(p, subtype_arrays->field3 + i);
}
static void fromwire_subtype_arrays(const u8 **cursor, size_t *plen, struct subtype_arrays *subtype_arrays)
{

 	fromwire_u8_array(cursor, plen, subtype_arrays->field1, 2);
 		for (size_t i = 0; i < 2; i++) {
		u16 tmp;
		tmp = fromwire_u16(cursor, plen);
		tal_arr_expand(&subtype_arrays->field2, tmp);
	}
 		for (size_t i = 0; i < 2; i++) {
		struct test_short_id tmp;
		fromwire_test_short_id(cursor, plen, &tmp);
		tal_arr_expand(&subtype_arrays->field3, tmp);
	}
}


struct tlv_test_n3 *tlv_test_n3_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_test_n3 *inst = talz(ctx, struct tlv_test_n3);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* TEST_N3 MSG: tlv3 */
static u8 *towire_tlv_test_n3_tlv3(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n3 *r = vrecord;
	u8 *ptr;

	if (!r->tlv3)
		return NULL;

	u16 len_varlen_ass = tal_count(r->tlv3->varlen_ass);
	u16 len_lf = tal_count(r->tlv3->localfeatures);
	u8 len_varlen = tal_count(r->tlv3->varlen_struct);
	u8 len_varlenvarsize = tal_count(r->tlv3->varlen_varsize);

	ptr = tal_arr(ctx, u8, 0);
	towire_test_short_id(&ptr, &r->tlv3->subtype);
	towire_subtype_var_len(&ptr, &r->tlv3->varlen_subtype);
	towire_subtype_var_assign(&ptr, &r->tlv3->varlen_assigned);
	towire_subtype_varlen_varsize(&ptr, &r->tlv3->test_sbt_varlen_varsize);
		for (size_t i = 0; i < 2; i++)
		towire_u32(&ptr, r->tlv3->arr_assign[i]);
		for (size_t i = 0; i < 2; i++)
		towire_test_short_id(&ptr, r->tlv3->arr_struct + i);
	towire_u16(&ptr, len_lf);
	towire_u8_array(&ptr, r->tlv3->localfeatures, len_lf);
	towire_u16(&ptr, len_varlen_ass);
		for (size_t i = 0; i < len_varlen_ass; i++)
		towire_u64(&ptr, r->tlv3->varlen_ass[i]);
	towire_u8(&ptr, len_varlen);
		for (size_t i = 0; i < len_varlen; i++)
		towire_test_short_id(&ptr, r->tlv3->varlen_struct + i);
	towire_u8(&ptr, len_varlenvarsize);
		for (size_t i = 0; i < len_varlenvarsize; i++)
		towire_test_features(&ptr, r->tlv3->varlen_varsize[i]);
	towire_u8_array(&ptr, r->tlv3->remainder, tal_count(r->tlv3->remainder));
	return ptr;
}
static void fromwire_tlv_test_n3_tlv3(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n3 *r = vrecord;
	u16 len_varlen_ass;
	u16 len_lf;
	u8 len_varlen;
	u8 len_varlenvarsize;

	r->tlv3 = tal(r, struct tlv_test_n3_tlv3);
	fromwire_test_short_id(cursor, plen, &r->tlv3->subtype);
	r->tlv3->varlen_subtype = *fromwire_subtype_var_len(r->tlv3, cursor, plen);
	r->tlv3->varlen_assigned = *fromwire_subtype_var_assign(r->tlv3, cursor, plen);
	r->tlv3->test_sbt_varlen_varsize = *fromwire_subtype_varlen_varsize(r->tlv3, cursor, plen);
		for (size_t i = 0; i < 2; i++) {
		u32 tmp;
		tmp = fromwire_u32(cursor, plen);
		tal_arr_expand(&r->tlv3->arr_assign, tmp);
	}
		for (size_t i = 0; i < 2; i++) {
		struct test_short_id tmp;
		fromwire_test_short_id(cursor, plen, &tmp);
		tal_arr_expand(&r->tlv3->arr_struct, tmp);
	}
	len_lf = fromwire_u16(cursor, plen);
	r->tlv3->localfeatures = len_lf ? tal_arr(r->tlv3, u8, len_lf) : NULL;
fromwire_u8_array(cursor, plen, r->tlv3->localfeatures, len_lf);
	len_varlen_ass = fromwire_u16(cursor, plen);
	r->tlv3->varlen_ass = len_varlen_ass ? tal_arr(r->tlv3, u64, 0) : NULL;
	for (size_t i = 0; i < len_varlen_ass; i++) {
		u64 tmp;
		tmp = fromwire_u64(cursor, plen);
		tal_arr_expand(&r->tlv3->varlen_ass, tmp);
	}
	len_varlen = fromwire_u8(cursor, plen);
	r->tlv3->varlen_struct = len_varlen ? tal_arr(r->tlv3, struct test_short_id, 0) : NULL;
	for (size_t i = 0; i < len_varlen; i++) {
		struct test_short_id tmp;
		fromwire_test_short_id(cursor, plen, &tmp);
		tal_arr_expand(&r->tlv3->varlen_struct, tmp);
	}
	len_varlenvarsize = fromwire_u8(cursor, plen);
	r->tlv3->varlen_varsize = len_varlenvarsize ? tal_arr(r->tlv3, struct test_features *, 0) : NULL;
	for (size_t i = 0; i < len_varlenvarsize; i++) {
		struct test_features * tmp;
		tmp = fromwire_test_features(r->tlv3, cursor, plen);
		tal_arr_expand(&r->tlv3->varlen_varsize, tmp);
	}
	r->tlv3->remainder = *plen ? tal_arr(r->tlv3, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->tlv3->remainder, *plen);
}

static const struct tlv_record_type tlvs_test_n3[] = {
	{ 1, towire_tlv_test_n3_tlv3, fromwire_tlv_test_n3_tlv3 },
};

void towire_test_n3(u8 **pptr,
			const void *record)
{
	size_t num_types = 1;
	const struct tlv_record_type *types = tlvs_test_n3;
	if (!record)
		return;

	for (size_t i = 0; i < num_types; i++) {
		u8 *val;
		if (i != 0)
			assert(types[i].type > types[i-1].type);
		val = types[i].towire(NULL, record);
		if (!val)
			continue;

		/* BOLT #1:
		 *
		 * The sending node:
		 ...
		 *  - MUST minimally encode `type` and `length`.
		 */
		towire_bigsize(pptr, types[i].type);
		towire_bigsize(pptr, tal_bytelen(val));
		towire(pptr, val, tal_bytelen(val));
		tal_free(val);
	}
}


bool fromwire_test_n3(const u8 **cursor, size_t *max, struct tlv_test_n3 *record)
{
	size_t num_types = 1;
	const struct tlv_record_type *types = tlvs_test_n3;
	while (*max > 0) {
		struct tlv_field field;

		/* BOLT #1:
		 *
		 * A `varint` is a variable-length, unsigned integer encoding
		 * using the [BigSize](#appendix-a-bigsize-test-vectors)
		 * format
		 */
		field.numtype = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("type");
			goto fail;
		}
		field.length = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("length");
			goto fail;
		}

		/* BOLT #1:
		 *  - if `length` exceeds the number of bytes remaining in the
		 *    message:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (field.length > *max) {
			SUPERVERBOSE("value");
			goto fail;
		}
		field.value = tal_dup_arr(record, u8, *cursor, field.length, 0);

		/* BOLT #1:
		 * - if `type` is known:
		 *   - MUST decode the next `length` bytes using the known
		 *     encoding for `type`.
		 */
		field.meta = NULL;
		for (size_t i = 0; i < num_types; i++) {
			if (types[i].type == field.numtype)
				field.meta = &types[i];
		}

		if (field.meta) {
			/* Length of message can't exceed 16 bits anyway. */
			size_t tlvlen = field.length;
			field.meta->fromwire(cursor, &tlvlen, record);

			if (!*cursor)
				goto fail;

			/* BOLT #1:
			 *  - if `length` is not exactly equal to that required
			 *    for the known encoding for `type`:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (tlvlen != 0) {
				SUPERVERBOSE("greater than encoding length");
				goto fail;
			}
		} else {
			/* We didn't read from *cursor through a fromwire, so
			 * update manually. */
			*cursor += field.length;
		}
		/* We've read bytes in ->fromwire, so update max */
		*max -= field.length;
		tal_arr_expand(&record->fields, field);
	}
	return true;
fail:
	fromwire_fail(cursor, max);
	return false;
}

bool test_n3_is_valid(const struct tlv_test_n3 *record, size_t *err_index)
{
	size_t numfields = tal_count(record->fields);
	bool first = true;
	u64 prev_type = 0;
	for (int i=0; i<numfields; i++) {
		struct tlv_field *f = &record->fields[i];
		if (f->numtype % 2 == 0 && f->meta == NULL) {
			/* BOLT #1:
			 * - otherwise, if `type` is unknown:
			 *   - if `type` is even:
			 *     - MUST fail to parse the `tlv_stream`.
			 *   - otherwise, if `type` is odd:
			 *     - MUST discard the next `length` bytes.
			 */
			SUPERVERBOSE("unknown even");
			if (err_index != NULL)
				*err_index = i;
			return false;
		} else if (!first && f->numtype <= prev_type) {
			/* BOLT #1:
			 *  - if decoded `type`s are not monotonically-increasing:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (f->numtype == prev_type)
				SUPERVERBOSE("duplicate tlv type");
			else
				SUPERVERBOSE("invalid ordering");
			if (err_index != NULL)
				*err_index = i;
			return false;
		}
		first = false;
		prev_type = f->numtype;
	}
	return true;
}


struct tlv_test_n2 *tlv_test_n2_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_test_n2 *inst = talz(ctx, struct tlv_test_n2);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* TEST_N2 MSG: tlv2 */
static u8 *towire_tlv_test_n2_tlv2(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n2 *r = vrecord;
	u8 *ptr;

	if (!r->tlv2)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_tu32(&ptr, r->tlv2->cltv_expiry);
	return ptr;
}
static void fromwire_tlv_test_n2_tlv2(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n2 *r = vrecord;

	r->tlv2 = tal(r, struct tlv_test_n2_tlv2);
	r->tlv2->cltv_expiry = fromwire_tu32(cursor, plen);
}
/* TEST_N2 MSG: tlv1 */
static u8 *towire_tlv_test_n2_tlv1(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n2 *r = vrecord;
	u8 *ptr;

	if (!r->tlv1)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_tu64(&ptr, r->tlv1->amount_msat);
	return ptr;
}
static void fromwire_tlv_test_n2_tlv1(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n2 *r = vrecord;

	r->tlv1 = tal(r, struct tlv_test_n2_tlv1);
	r->tlv1->amount_msat = fromwire_tu64(cursor, plen);
}

static const struct tlv_record_type tlvs_test_n2[] = {
	{ 0, towire_tlv_test_n2_tlv1, fromwire_tlv_test_n2_tlv1 },
	{ 11, towire_tlv_test_n2_tlv2, fromwire_tlv_test_n2_tlv2 },
};

void towire_test_n2(u8 **pptr,
			const void *record)
{
	size_t num_types = 2;
	const struct tlv_record_type *types = tlvs_test_n2;
	if (!record)
		return;

	for (size_t i = 0; i < num_types; i++) {
		u8 *val;
		if (i != 0)
			assert(types[i].type > types[i-1].type);
		val = types[i].towire(NULL, record);
		if (!val)
			continue;

		/* BOLT #1:
		 *
		 * The sending node:
		 ...
		 *  - MUST minimally encode `type` and `length`.
		 */
		towire_bigsize(pptr, types[i].type);
		towire_bigsize(pptr, tal_bytelen(val));
		towire(pptr, val, tal_bytelen(val));
		tal_free(val);
	}
}


bool fromwire_test_n2(const u8 **cursor, size_t *max, struct tlv_test_n2 *record)
{
	size_t num_types = 2;
	const struct tlv_record_type *types = tlvs_test_n2;
	while (*max > 0) {
		struct tlv_field field;

		/* BOLT #1:
		 *
		 * A `varint` is a variable-length, unsigned integer encoding
		 * using the [BigSize](#appendix-a-bigsize-test-vectors)
		 * format
		 */
		field.numtype = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("type");
			goto fail;
		}
		field.length = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("length");
			goto fail;
		}

		/* BOLT #1:
		 *  - if `length` exceeds the number of bytes remaining in the
		 *    message:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (field.length > *max) {
			SUPERVERBOSE("value");
			goto fail;
		}
		field.value = tal_dup_arr(record, u8, *cursor, field.length, 0);

		/* BOLT #1:
		 * - if `type` is known:
		 *   - MUST decode the next `length` bytes using the known
		 *     encoding for `type`.
		 */
		field.meta = NULL;
		for (size_t i = 0; i < num_types; i++) {
			if (types[i].type == field.numtype)
				field.meta = &types[i];
		}

		if (field.meta) {
			/* Length of message can't exceed 16 bits anyway. */
			size_t tlvlen = field.length;
			field.meta->fromwire(cursor, &tlvlen, record);

			if (!*cursor)
				goto fail;

			/* BOLT #1:
			 *  - if `length` is not exactly equal to that required
			 *    for the known encoding for `type`:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (tlvlen != 0) {
				SUPERVERBOSE("greater than encoding length");
				goto fail;
			}
		} else {
			/* We didn't read from *cursor through a fromwire, so
			 * update manually. */
			*cursor += field.length;
		}
		/* We've read bytes in ->fromwire, so update max */
		*max -= field.length;
		tal_arr_expand(&record->fields, field);
	}
	return true;
fail:
	fromwire_fail(cursor, max);
	return false;
}

bool test_n2_is_valid(const struct tlv_test_n2 *record, size_t *err_index)
{
	size_t numfields = tal_count(record->fields);
	bool first = true;
	u64 prev_type = 0;
	for (int i=0; i<numfields; i++) {
		struct tlv_field *f = &record->fields[i];
		if (f->numtype % 2 == 0 && f->meta == NULL) {
			/* BOLT #1:
			 * - otherwise, if `type` is unknown:
			 *   - if `type` is even:
			 *     - MUST fail to parse the `tlv_stream`.
			 *   - otherwise, if `type` is odd:
			 *     - MUST discard the next `length` bytes.
			 */
			SUPERVERBOSE("unknown even");
			if (err_index != NULL)
				*err_index = i;
			return false;
		} else if (!first && f->numtype <= prev_type) {
			/* BOLT #1:
			 *  - if decoded `type`s are not monotonically-increasing:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (f->numtype == prev_type)
				SUPERVERBOSE("duplicate tlv type");
			else
				SUPERVERBOSE("invalid ordering");
			if (err_index != NULL)
				*err_index = i;
			return false;
		}
		first = false;
		prev_type = f->numtype;
	}
	return true;
}


struct tlv_test_n1 *tlv_test_n1_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_test_n1 *inst = talz(ctx, struct tlv_test_n1);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* TEST_N1 MSG: tlv3 */
static u8 *towire_tlv_test_n1_tlv3(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv3)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_test_features(&ptr, &r->tlv3->features);
	towire_amount_msat(&ptr, r->tlv3->amount_msat_1);
	towire_amount_msat(&ptr, r->tlv3->amount_msat_2);
	return ptr;
}
static void fromwire_tlv_test_n1_tlv3(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n1 *r = vrecord;

	r->tlv3 = tal(r, struct tlv_test_n1_tlv3);
	r->tlv3->features = *fromwire_test_features(r->tlv3, cursor, plen);
	r->tlv3->amount_msat_1 = fromwire_amount_msat(cursor, plen);
	r->tlv3->amount_msat_2 = fromwire_amount_msat(cursor, plen);
}
/* TEST_N1 MSG: tlv2 */
static u8 *towire_tlv_test_n1_tlv2(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv2)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_test_short_id(&ptr, &r->tlv2->scid);
	return ptr;
}
static void fromwire_tlv_test_n1_tlv2(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n1 *r = vrecord;

	r->tlv2 = tal(r, struct tlv_test_n1_tlv2);
	fromwire_test_short_id(cursor, plen, &r->tlv2->scid);
}
/* TEST_N1 MSG: tlv1 */
static u8 *towire_tlv_test_n1_tlv1(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv1)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_tu64(&ptr, r->tlv1->amount_msat);
	return ptr;
}
static void fromwire_tlv_test_n1_tlv1(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n1 *r = vrecord;

	r->tlv1 = tal(r, struct tlv_test_n1_tlv1);
	r->tlv1->amount_msat = fromwire_tu64(cursor, plen);
}
/* TEST_N1 MSG: tlv4 */
static u8 *towire_tlv_test_n1_tlv4(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_test_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv4)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	towire_u16(&ptr, r->tlv4->cltv_delta);
	return ptr;
}
static void fromwire_tlv_test_n1_tlv4(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_test_n1 *r = vrecord;

	r->tlv4 = tal(r, struct tlv_test_n1_tlv4);
	r->tlv4->cltv_delta = fromwire_u16(cursor, plen);
}

static const struct tlv_record_type tlvs_test_n1[] = {
	{ 1, towire_tlv_test_n1_tlv1, fromwire_tlv_test_n1_tlv1 },
	{ 2, towire_tlv_test_n1_tlv2, fromwire_tlv_test_n1_tlv2 },
	{ 3, towire_tlv_test_n1_tlv3, fromwire_tlv_test_n1_tlv3 },
	{ 254, towire_tlv_test_n1_tlv4, fromwire_tlv_test_n1_tlv4 },
};

void towire_test_n1(u8 **pptr,
			const void *record)
{
	size_t num_types = 4;
	const struct tlv_record_type *types = tlvs_test_n1;
	if (!record)
		return;

	for (size_t i = 0; i < num_types; i++) {
		u8 *val;
		if (i != 0)
			assert(types[i].type > types[i-1].type);
		val = types[i].towire(NULL, record);
		if (!val)
			continue;

		/* BOLT #1:
		 *
		 * The sending node:
		 ...
		 *  - MUST minimally encode `type` and `length`.
		 */
		towire_bigsize(pptr, types[i].type);
		towire_bigsize(pptr, tal_bytelen(val));
		towire(pptr, val, tal_bytelen(val));
		tal_free(val);
	}
}


bool fromwire_test_n1(const u8 **cursor, size_t *max, struct tlv_test_n1 *record)
{
	size_t num_types = 4;
	const struct tlv_record_type *types = tlvs_test_n1;
	while (*max > 0) {
		struct tlv_field field;

		/* BOLT #1:
		 *
		 * A `varint` is a variable-length, unsigned integer encoding
		 * using the [BigSize](#appendix-a-bigsize-test-vectors)
		 * format
		 */
		field.numtype = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("type");
			goto fail;
		}
		field.length = fromwire_bigsize(cursor, max);

		/* BOLT #1:
		 *  - if a `type` or `length` is not minimally encoded:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (!*cursor) {
			SUPERVERBOSE("length");
			goto fail;
		}

		/* BOLT #1:
		 *  - if `length` exceeds the number of bytes remaining in the
		 *    message:
		 *    - MUST fail to parse the `tlv_stream`.
		 */
		if (field.length > *max) {
			SUPERVERBOSE("value");
			goto fail;
		}
		field.value = tal_dup_arr(record, u8, *cursor, field.length, 0);

		/* BOLT #1:
		 * - if `type` is known:
		 *   - MUST decode the next `length` bytes using the known
		 *     encoding for `type`.
		 */
		field.meta = NULL;
		for (size_t i = 0; i < num_types; i++) {
			if (types[i].type == field.numtype)
				field.meta = &types[i];
		}

		if (field.meta) {
			/* Length of message can't exceed 16 bits anyway. */
			size_t tlvlen = field.length;
			field.meta->fromwire(cursor, &tlvlen, record);

			if (!*cursor)
				goto fail;

			/* BOLT #1:
			 *  - if `length` is not exactly equal to that required
			 *    for the known encoding for `type`:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (tlvlen != 0) {
				SUPERVERBOSE("greater than encoding length");
				goto fail;
			}
		} else {
			/* We didn't read from *cursor through a fromwire, so
			 * update manually. */
			*cursor += field.length;
		}
		/* We've read bytes in ->fromwire, so update max */
		*max -= field.length;
		tal_arr_expand(&record->fields, field);
	}
	return true;
fail:
	fromwire_fail(cursor, max);
	return false;
}

bool test_n1_is_valid(const struct tlv_test_n1 *record, size_t *err_index)
{
	size_t numfields = tal_count(record->fields);
	bool first = true;
	u64 prev_type = 0;
	for (int i=0; i<numfields; i++) {
		struct tlv_field *f = &record->fields[i];
		if (f->numtype % 2 == 0 && f->meta == NULL) {
			/* BOLT #1:
			 * - otherwise, if `type` is unknown:
			 *   - if `type` is even:
			 *     - MUST fail to parse the `tlv_stream`.
			 *   - otherwise, if `type` is odd:
			 *     - MUST discard the next `length` bytes.
			 */
			SUPERVERBOSE("unknown even");
			if (err_index != NULL)
				*err_index = i;
			return false;
		} else if (!first && f->numtype <= prev_type) {
			/* BOLT #1:
			 *  - if decoded `type`s are not monotonically-increasing:
			 *    - MUST fail to parse the `tlv_stream`.
			 */
			if (f->numtype == prev_type)
				SUPERVERBOSE("duplicate tlv type");
			else
				SUPERVERBOSE("invalid ordering");
			if (err_index != NULL)
				*err_index = i;
			return false;
		}
		first = false;
		prev_type = f->numtype;
	}
	return true;
}


/* WIRE: TEST_MSG */
/* omnibus method */
u8 *towire_test_msg(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays)
{
	u16 len_var_u8 = tal_count(test_var_len_u8_arr);
	u16 len_varsize_struct = tal_count(test_varsize_struct_varlen);
	u16 len_var_ass = tal_count(test_var_len_ass_arr);
	u16 len_test_struct_varlen = tal_count(test_struct_varlen);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_MSG);
	/* test array u8 (helper) */
	towire_u8_array(&p, test_arr_u8, 10);
	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		towire_u16(&p, test_arr_assignable[i]);
	/* test var len u8 (helper) */
	towire_u16(&p, len_var_u8);
	towire_u8_array(&p, test_var_len_u8_arr, len_var_u8);
	/* test variable length assignable */
	towire_u16(&p, len_var_ass);
	for (size_t i = 0; i < len_var_ass; i++)
		towire_u32(&p, test_var_len_ass_arr[i]);
	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		towire_test_short_id(&p, test_struct_arr + i);
	/* test var-len struct */
	towire_u16(&p, len_test_struct_varlen);
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		towire_test_short_id(&p, test_struct_varlen + i);
	/* test var-len var-size struct */
	towire_u16(&p, len_varsize_struct);
	for (size_t i = 0; i < len_varsize_struct; i++)
		towire_test_features(&p, test_varsize_struct_varlen[i]);
	/* assignable */
	towire_u16(&p, test_assignable);
	/* enum */
	towire_test_enum(&p, test_enum);
	/* test struct */
	towire_test_short_id(&p, test_struct);
	/* test var-size struct */
	towire_test_features(&p, test_varsize_struct);
	/* test optional assignable */
	if (!test_optional_assignable)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_u32(&p, *test_optional_assignable);
	}
	/* test optional struct */
	if (!test_optional_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_short_id(&p, test_optional_struct);
	}
	/* test optional var-size struct */
	if (!test_optional_varsize_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_features(&p, test_optional_varsize_struct);
	}
	towire_subtype_nested(&p, test_sbt_struct_nested);
	towire_subtype_varsize_struct(&p, test_sbt_varsize_struct);
	towire_subtype_var_assign(&p, test_sbt_varsize_var_assign);
	towire_subtype_var_len(&p, test_sbt_var_len);
	towire_subtype_varlen_varsize(&p, test_sbt_varlen_varsize);
	towire_subtype_arrays(&p, test_sbt_arrays);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_msg(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays)
{
	u16 len_var_u8;
	u16 len_varsize_struct;
	u16 len_var_ass;
	u16 len_test_struct_varlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_MSG)
		return false;
 	/* test array u8 (helper) */
	fromwire_u8_array(&cursor, &plen, test_arr_u8, 10);
 	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		(test_arr_assignable)[i] = fromwire_u16(&cursor, &plen);
 	/* test var len u8 (helper) */
	len_var_u8 = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_u8_arr
	*test_var_len_u8_arr = len_var_u8 ? tal_arr(ctx, u8, len_var_u8) : NULL;
	fromwire_u8_array(&cursor, &plen, *test_var_len_u8_arr, len_var_u8);
 	/* test variable length assignable */
	len_var_ass = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_ass_arr
	*test_var_len_ass_arr = len_var_ass ? tal_arr(ctx, u32, len_var_ass) : NULL;
	for (size_t i = 0; i < len_var_ass; i++)
		(*test_var_len_ass_arr)[i] = fromwire_u32(&cursor, &plen);
 	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		fromwire_test_short_id(&cursor, &plen, &(test_struct_arr[i]));
 	/* test var-len struct */
	len_test_struct_varlen = fromwire_u16(&cursor, &plen);
 	// 2nd case test_struct_varlen
	*test_struct_varlen = len_test_struct_varlen ? tal_arr(ctx, struct test_short_id, len_test_struct_varlen) : NULL;
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		fromwire_test_short_id(&cursor, &plen, *test_struct_varlen + i);
 	/* test var-len var-size struct */
	len_varsize_struct = fromwire_u16(&cursor, &plen);
 	// 2nd case test_varsize_struct_varlen
	*test_varsize_struct_varlen = len_varsize_struct ? tal_arr(ctx, struct test_features *, len_varsize_struct) : NULL;
	for (size_t i = 0; i < len_varsize_struct; i++)
		(*test_varsize_struct_varlen)[i] = fromwire_test_features(*test_varsize_struct_varlen, &cursor, &plen);
 	/* assignable */
	*test_assignable = fromwire_u16(&cursor, &plen);
 	/* enum */
	*test_enum = fromwire_test_enum(&cursor, &plen);
 	/* test struct */
	fromwire_test_short_id(&cursor, &plen, test_struct);
 	/* test var-size struct */
	*test_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
 	/* test optional assignable */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_assignable = NULL;
	else {
		*test_optional_assignable = tal(ctx, u32);
		**test_optional_assignable = fromwire_u32(&cursor, &plen);
	}
 	/* test optional struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_struct = NULL;
	else {
		*test_optional_struct = tal(ctx, struct test_short_id);
		fromwire_test_short_id(&cursor, &plen, *test_optional_struct);
	}
 	/* test optional var-size struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_varsize_struct = NULL;
	else {
		*test_optional_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
	}
 	fromwire_subtype_nested(&cursor, &plen, test_sbt_struct_nested);
 	fromwire_subtype_varsize_struct(&cursor, &plen, test_sbt_varsize_struct);
 	*test_sbt_varsize_var_assign = fromwire_subtype_var_assign(ctx, &cursor, &plen);
 	*test_sbt_var_len = fromwire_subtype_var_len(ctx, &cursor, &plen);
 	*test_sbt_varlen_varsize = fromwire_subtype_varlen_varsize(ctx, &cursor, &plen);
 	fromwire_subtype_arrays(&cursor, &plen, test_sbt_arrays);
	return cursor != NULL;
}

/* WIRE: TEST_TLV3 */
u8 *towire_test_tlv3(const tal_t *ctx, const struct tlv_test_n3 *tlv)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_TLV3);
	towire_test_n3(&p, tlv);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_tlv3(const void *p, struct tlv_test_n3 *tlv)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_TLV3)
		return false;
 	fromwire_test_n3(&cursor, &plen, tlv);
	return cursor != NULL;
}

/* WIRE: TEST_TLV1 */
u8 *towire_test_tlv1(const tal_t *ctx, const struct test_short_id *test_struct, const struct tlv_test_n1 *tlv)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_TLV1);
	towire_test_short_id(&p, test_struct);
	towire_test_n1(&p, tlv);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_tlv1(const void *p, struct test_short_id *test_struct, struct tlv_test_n1 *tlv)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_TLV1)
		return false;
 	fromwire_test_short_id(&cursor, &plen, test_struct);
 	fromwire_test_n1(&cursor, &plen, tlv);
	return cursor != NULL;
}

#if TEST_IFDEF
/* WIRE: TEST_IFDEF */
u8 *towire_test_ifdef(const tal_t *ctx, u32 is_def)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_IFDEF);
	towire_u32(&p, is_def);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_ifdef(const void *p, u32 *is_def)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_IFDEF)
		return false;
 	*is_def = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}
#endif /* TEST_IFDEF */

/* WIRE: TEST_TLV2 */
u8 *towire_test_tlv2(const tal_t *ctx, const struct tlv_test_n2 *tlv)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_TLV2);
	towire_test_n2(&p, tlv);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_tlv2(const void *p, struct tlv_test_n2 *tlv)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_TLV2)
		return false;
 	fromwire_test_n2(&cursor, &plen, tlv);
	return cursor != NULL;
}

/* WIRE: TEST_MSG_OPTION_ONE */
/* omnibus method */
u8 *towire_test_msg_option_one(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_short_id *extension_2)
{
	u16 len_var_u8 = tal_count(test_var_len_u8_arr);
	u16 len_varsize_struct = tal_count(test_varsize_struct_varlen);
	u16 len_var_ass = tal_count(test_var_len_ass_arr);
	u16 len_test_struct_varlen = tal_count(test_struct_varlen);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_MSG);
	/* test array u8 (helper) */
	towire_u8_array(&p, test_arr_u8, 10);
	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		towire_u16(&p, test_arr_assignable[i]);
	/* test var len u8 (helper) */
	towire_u16(&p, len_var_u8);
	towire_u8_array(&p, test_var_len_u8_arr, len_var_u8);
	/* test variable length assignable */
	towire_u16(&p, len_var_ass);
	for (size_t i = 0; i < len_var_ass; i++)
		towire_u32(&p, test_var_len_ass_arr[i]);
	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		towire_test_short_id(&p, test_struct_arr + i);
	/* test var-len struct */
	towire_u16(&p, len_test_struct_varlen);
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		towire_test_short_id(&p, test_struct_varlen + i);
	/* test var-len var-size struct */
	towire_u16(&p, len_varsize_struct);
	for (size_t i = 0; i < len_varsize_struct; i++)
		towire_test_features(&p, test_varsize_struct_varlen[i]);
	/* assignable */
	towire_u16(&p, test_assignable);
	/* enum */
	towire_test_enum(&p, test_enum);
	/* test struct */
	towire_test_short_id(&p, test_struct);
	/* test var-size struct */
	towire_test_features(&p, test_varsize_struct);
	/* test optional assignable */
	if (!test_optional_assignable)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_u32(&p, *test_optional_assignable);
	}
	/* test optional struct */
	if (!test_optional_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_short_id(&p, test_optional_struct);
	}
	/* test optional var-size struct */
	if (!test_optional_varsize_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_features(&p, test_optional_varsize_struct);
	}
	towire_subtype_nested(&p, test_sbt_struct_nested);
	towire_subtype_varsize_struct(&p, test_sbt_varsize_struct);
	towire_subtype_var_assign(&p, test_sbt_varsize_var_assign);
	towire_subtype_var_len(&p, test_sbt_var_len);
	towire_subtype_varlen_varsize(&p, test_sbt_varlen_varsize);
	towire_subtype_arrays(&p, test_sbt_arrays);
	towire_test_short_id(&p, extension_2);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_msg_option_one(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_short_id *extension_2)
{
	u16 len_var_u8;
	u16 len_varsize_struct;
	u16 len_var_ass;
	u16 len_test_struct_varlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_MSG)
		return false;
 	/* test array u8 (helper) */
	fromwire_u8_array(&cursor, &plen, test_arr_u8, 10);
 	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		(test_arr_assignable)[i] = fromwire_u16(&cursor, &plen);
 	/* test var len u8 (helper) */
	len_var_u8 = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_u8_arr
	*test_var_len_u8_arr = len_var_u8 ? tal_arr(ctx, u8, len_var_u8) : NULL;
	fromwire_u8_array(&cursor, &plen, *test_var_len_u8_arr, len_var_u8);
 	/* test variable length assignable */
	len_var_ass = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_ass_arr
	*test_var_len_ass_arr = len_var_ass ? tal_arr(ctx, u32, len_var_ass) : NULL;
	for (size_t i = 0; i < len_var_ass; i++)
		(*test_var_len_ass_arr)[i] = fromwire_u32(&cursor, &plen);
 	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		fromwire_test_short_id(&cursor, &plen, &(test_struct_arr[i]));
 	/* test var-len struct */
	len_test_struct_varlen = fromwire_u16(&cursor, &plen);
 	// 2nd case test_struct_varlen
	*test_struct_varlen = len_test_struct_varlen ? tal_arr(ctx, struct test_short_id, len_test_struct_varlen) : NULL;
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		fromwire_test_short_id(&cursor, &plen, *test_struct_varlen + i);
 	/* test var-len var-size struct */
	len_varsize_struct = fromwire_u16(&cursor, &plen);
 	// 2nd case test_varsize_struct_varlen
	*test_varsize_struct_varlen = len_varsize_struct ? tal_arr(ctx, struct test_features *, len_varsize_struct) : NULL;
	for (size_t i = 0; i < len_varsize_struct; i++)
		(*test_varsize_struct_varlen)[i] = fromwire_test_features(*test_varsize_struct_varlen, &cursor, &plen);
 	/* assignable */
	*test_assignable = fromwire_u16(&cursor, &plen);
 	/* enum */
	*test_enum = fromwire_test_enum(&cursor, &plen);
 	/* test struct */
	fromwire_test_short_id(&cursor, &plen, test_struct);
 	/* test var-size struct */
	*test_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
 	/* test optional assignable */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_assignable = NULL;
	else {
		*test_optional_assignable = tal(ctx, u32);
		**test_optional_assignable = fromwire_u32(&cursor, &plen);
	}
 	/* test optional struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_struct = NULL;
	else {
		*test_optional_struct = tal(ctx, struct test_short_id);
		fromwire_test_short_id(&cursor, &plen, *test_optional_struct);
	}
 	/* test optional var-size struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_varsize_struct = NULL;
	else {
		*test_optional_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
	}
 	fromwire_subtype_nested(&cursor, &plen, test_sbt_struct_nested);
 	fromwire_subtype_varsize_struct(&cursor, &plen, test_sbt_varsize_struct);
 	*test_sbt_varsize_var_assign = fromwire_subtype_var_assign(ctx, &cursor, &plen);
 	*test_sbt_var_len = fromwire_subtype_var_len(ctx, &cursor, &plen);
 	*test_sbt_varlen_varsize = fromwire_subtype_varlen_varsize(ctx, &cursor, &plen);
 	fromwire_subtype_arrays(&cursor, &plen, test_sbt_arrays);
 	fromwire_test_short_id(&cursor, &plen, extension_2);
	return cursor != NULL;
}

/* WIRE: TEST_MSG_OPTION_TWO */
/* omnibus method */
u8 *towire_test_msg_option_two(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_short_id *extension_2)
{
	u16 len_var_u8 = tal_count(test_var_len_u8_arr);
	u16 len_varsize_struct = tal_count(test_varsize_struct_varlen);
	u16 len_var_ass = tal_count(test_var_len_ass_arr);
	u16 len_test_struct_varlen = tal_count(test_struct_varlen);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_MSG);
	/* test array u8 (helper) */
	towire_u8_array(&p, test_arr_u8, 10);
	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		towire_u16(&p, test_arr_assignable[i]);
	/* test var len u8 (helper) */
	towire_u16(&p, len_var_u8);
	towire_u8_array(&p, test_var_len_u8_arr, len_var_u8);
	/* test variable length assignable */
	towire_u16(&p, len_var_ass);
	for (size_t i = 0; i < len_var_ass; i++)
		towire_u32(&p, test_var_len_ass_arr[i]);
	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		towire_test_short_id(&p, test_struct_arr + i);
	/* test var-len struct */
	towire_u16(&p, len_test_struct_varlen);
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		towire_test_short_id(&p, test_struct_varlen + i);
	/* test var-len var-size struct */
	towire_u16(&p, len_varsize_struct);
	for (size_t i = 0; i < len_varsize_struct; i++)
		towire_test_features(&p, test_varsize_struct_varlen[i]);
	/* assignable */
	towire_u16(&p, test_assignable);
	/* enum */
	towire_test_enum(&p, test_enum);
	/* test struct */
	towire_test_short_id(&p, test_struct);
	/* test var-size struct */
	towire_test_features(&p, test_varsize_struct);
	/* test optional assignable */
	if (!test_optional_assignable)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_u32(&p, *test_optional_assignable);
	}
	/* test optional struct */
	if (!test_optional_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_short_id(&p, test_optional_struct);
	}
	/* test optional var-size struct */
	if (!test_optional_varsize_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_features(&p, test_optional_varsize_struct);
	}
	towire_subtype_nested(&p, test_sbt_struct_nested);
	towire_subtype_varsize_struct(&p, test_sbt_varsize_struct);
	towire_subtype_var_assign(&p, test_sbt_varsize_var_assign);
	towire_subtype_var_len(&p, test_sbt_var_len);
	towire_subtype_varlen_varsize(&p, test_sbt_varlen_varsize);
	towire_subtype_arrays(&p, test_sbt_arrays);
	towire_test_short_id(&p, extension_2);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_msg_option_two(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_short_id *extension_2)
{
	u16 len_var_u8;
	u16 len_varsize_struct;
	u16 len_var_ass;
	u16 len_test_struct_varlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_MSG)
		return false;
 	/* test array u8 (helper) */
	fromwire_u8_array(&cursor, &plen, test_arr_u8, 10);
 	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		(test_arr_assignable)[i] = fromwire_u16(&cursor, &plen);
 	/* test var len u8 (helper) */
	len_var_u8 = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_u8_arr
	*test_var_len_u8_arr = len_var_u8 ? tal_arr(ctx, u8, len_var_u8) : NULL;
	fromwire_u8_array(&cursor, &plen, *test_var_len_u8_arr, len_var_u8);
 	/* test variable length assignable */
	len_var_ass = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_ass_arr
	*test_var_len_ass_arr = len_var_ass ? tal_arr(ctx, u32, len_var_ass) : NULL;
	for (size_t i = 0; i < len_var_ass; i++)
		(*test_var_len_ass_arr)[i] = fromwire_u32(&cursor, &plen);
 	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		fromwire_test_short_id(&cursor, &plen, &(test_struct_arr[i]));
 	/* test var-len struct */
	len_test_struct_varlen = fromwire_u16(&cursor, &plen);
 	// 2nd case test_struct_varlen
	*test_struct_varlen = len_test_struct_varlen ? tal_arr(ctx, struct test_short_id, len_test_struct_varlen) : NULL;
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		fromwire_test_short_id(&cursor, &plen, *test_struct_varlen + i);
 	/* test var-len var-size struct */
	len_varsize_struct = fromwire_u16(&cursor, &plen);
 	// 2nd case test_varsize_struct_varlen
	*test_varsize_struct_varlen = len_varsize_struct ? tal_arr(ctx, struct test_features *, len_varsize_struct) : NULL;
	for (size_t i = 0; i < len_varsize_struct; i++)
		(*test_varsize_struct_varlen)[i] = fromwire_test_features(*test_varsize_struct_varlen, &cursor, &plen);
 	/* assignable */
	*test_assignable = fromwire_u16(&cursor, &plen);
 	/* enum */
	*test_enum = fromwire_test_enum(&cursor, &plen);
 	/* test struct */
	fromwire_test_short_id(&cursor, &plen, test_struct);
 	/* test var-size struct */
	*test_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
 	/* test optional assignable */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_assignable = NULL;
	else {
		*test_optional_assignable = tal(ctx, u32);
		**test_optional_assignable = fromwire_u32(&cursor, &plen);
	}
 	/* test optional struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_struct = NULL;
	else {
		*test_optional_struct = tal(ctx, struct test_short_id);
		fromwire_test_short_id(&cursor, &plen, *test_optional_struct);
	}
 	/* test optional var-size struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_varsize_struct = NULL;
	else {
		*test_optional_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
	}
 	fromwire_subtype_nested(&cursor, &plen, test_sbt_struct_nested);
 	fromwire_subtype_varsize_struct(&cursor, &plen, test_sbt_varsize_struct);
 	*test_sbt_varsize_var_assign = fromwire_subtype_var_assign(ctx, &cursor, &plen);
 	*test_sbt_var_len = fromwire_subtype_var_len(ctx, &cursor, &plen);
 	*test_sbt_varlen_varsize = fromwire_subtype_varlen_varsize(ctx, &cursor, &plen);
 	fromwire_subtype_arrays(&cursor, &plen, test_sbt_arrays);
 	fromwire_test_short_id(&cursor, &plen, extension_2);
	return cursor != NULL;
}

/* WIRE: TEST_MSG_OPTION_SHORT_ID */
/* omnibus method */
u8 *towire_test_msg_option_short_id(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_features *extension_1)
{
	u16 len_var_u8 = tal_count(test_var_len_u8_arr);
	u16 len_varsize_struct = tal_count(test_varsize_struct_varlen);
	u16 len_var_ass = tal_count(test_var_len_ass_arr);
	u16 len_test_struct_varlen = tal_count(test_struct_varlen);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TEST_MSG);
	/* test array u8 (helper) */
	towire_u8_array(&p, test_arr_u8, 10);
	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		towire_u16(&p, test_arr_assignable[i]);
	/* test var len u8 (helper) */
	towire_u16(&p, len_var_u8);
	towire_u8_array(&p, test_var_len_u8_arr, len_var_u8);
	/* test variable length assignable */
	towire_u16(&p, len_var_ass);
	for (size_t i = 0; i < len_var_ass; i++)
		towire_u32(&p, test_var_len_ass_arr[i]);
	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		towire_test_short_id(&p, test_struct_arr + i);
	/* test var-len struct */
	towire_u16(&p, len_test_struct_varlen);
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		towire_test_short_id(&p, test_struct_varlen + i);
	/* test var-len var-size struct */
	towire_u16(&p, len_varsize_struct);
	for (size_t i = 0; i < len_varsize_struct; i++)
		towire_test_features(&p, test_varsize_struct_varlen[i]);
	/* assignable */
	towire_u16(&p, test_assignable);
	/* enum */
	towire_test_enum(&p, test_enum);
	/* test struct */
	towire_test_short_id(&p, test_struct);
	/* test var-size struct */
	towire_test_features(&p, test_varsize_struct);
	/* test optional assignable */
	if (!test_optional_assignable)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_u32(&p, *test_optional_assignable);
	}
	/* test optional struct */
	if (!test_optional_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_short_id(&p, test_optional_struct);
	}
	/* test optional var-size struct */
	if (!test_optional_varsize_struct)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_test_features(&p, test_optional_varsize_struct);
	}
	towire_subtype_nested(&p, test_sbt_struct_nested);
	towire_subtype_varsize_struct(&p, test_sbt_varsize_struct);
	towire_subtype_var_assign(&p, test_sbt_varsize_var_assign);
	towire_subtype_var_len(&p, test_sbt_var_len);
	towire_subtype_varlen_varsize(&p, test_sbt_varlen_varsize);
	towire_subtype_arrays(&p, test_sbt_arrays);
	/* test extension fields */
	towire_test_features(&p, extension_1);

	return memcheck(p, tal_count(p));
}
bool fromwire_test_msg_option_short_id(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_features **extension_1)
{
	u16 len_var_u8;
	u16 len_varsize_struct;
	u16 len_var_ass;
	u16 len_test_struct_varlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TEST_MSG)
		return false;
 	/* test array u8 (helper) */
	fromwire_u8_array(&cursor, &plen, test_arr_u8, 10);
 	/* test array assignable */
	for (size_t i = 0; i < 5; i++)
		(test_arr_assignable)[i] = fromwire_u16(&cursor, &plen);
 	/* test var len u8 (helper) */
	len_var_u8 = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_u8_arr
	*test_var_len_u8_arr = len_var_u8 ? tal_arr(ctx, u8, len_var_u8) : NULL;
	fromwire_u8_array(&cursor, &plen, *test_var_len_u8_arr, len_var_u8);
 	/* test variable length assignable */
	len_var_ass = fromwire_u16(&cursor, &plen);
 	// 2nd case test_var_len_ass_arr
	*test_var_len_ass_arr = len_var_ass ? tal_arr(ctx, u32, len_var_ass) : NULL;
	for (size_t i = 0; i < len_var_ass; i++)
		(*test_var_len_ass_arr)[i] = fromwire_u32(&cursor, &plen);
 	/* test array struct */
	for (size_t i = 0; i < 10; i++)
		fromwire_test_short_id(&cursor, &plen, &(test_struct_arr[i]));
 	/* test var-len struct */
	len_test_struct_varlen = fromwire_u16(&cursor, &plen);
 	// 2nd case test_struct_varlen
	*test_struct_varlen = len_test_struct_varlen ? tal_arr(ctx, struct test_short_id, len_test_struct_varlen) : NULL;
	for (size_t i = 0; i < len_test_struct_varlen; i++)
		fromwire_test_short_id(&cursor, &plen, *test_struct_varlen + i);
 	/* test var-len var-size struct */
	len_varsize_struct = fromwire_u16(&cursor, &plen);
 	// 2nd case test_varsize_struct_varlen
	*test_varsize_struct_varlen = len_varsize_struct ? tal_arr(ctx, struct test_features *, len_varsize_struct) : NULL;
	for (size_t i = 0; i < len_varsize_struct; i++)
		(*test_varsize_struct_varlen)[i] = fromwire_test_features(*test_varsize_struct_varlen, &cursor, &plen);
 	/* assignable */
	*test_assignable = fromwire_u16(&cursor, &plen);
 	/* enum */
	*test_enum = fromwire_test_enum(&cursor, &plen);
 	/* test struct */
	fromwire_test_short_id(&cursor, &plen, test_struct);
 	/* test var-size struct */
	*test_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
 	/* test optional assignable */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_assignable = NULL;
	else {
		*test_optional_assignable = tal(ctx, u32);
		**test_optional_assignable = fromwire_u32(&cursor, &plen);
	}
 	/* test optional struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_struct = NULL;
	else {
		*test_optional_struct = tal(ctx, struct test_short_id);
		fromwire_test_short_id(&cursor, &plen, *test_optional_struct);
	}
 	/* test optional var-size struct */
	if (!fromwire_bool(&cursor, &plen))
		*test_optional_varsize_struct = NULL;
	else {
		*test_optional_varsize_struct = fromwire_test_features(ctx, &cursor, &plen);
	}
 	fromwire_subtype_nested(&cursor, &plen, test_sbt_struct_nested);
 	fromwire_subtype_varsize_struct(&cursor, &plen, test_sbt_varsize_struct);
 	*test_sbt_varsize_var_assign = fromwire_subtype_var_assign(ctx, &cursor, &plen);
 	*test_sbt_var_len = fromwire_subtype_var_len(ctx, &cursor, &plen);
 	*test_sbt_varlen_varsize = fromwire_subtype_varlen_varsize(ctx, &cursor, &plen);
 	fromwire_subtype_arrays(&cursor, &plen, test_sbt_arrays);
 	/* test extension fields */
	*extension_1 = fromwire_test_features(ctx, &cursor, &plen);
	return cursor != NULL;
}

