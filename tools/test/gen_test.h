/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/header_template */

#ifndef LIGHTNING_TOOLS_TEST_GEN_TEST_H
#define LIGHTNING_TOOLS_TEST_GEN_TEST_H
#include <ccan/tal/tal.h>
#include <wire/tlvstream.h>
#include <wire/wire.h>
#include <ccan/short_types/short_types.h>
#include "enum.h"

enum test_type {
        /*  omnibus method */
        WIRE_TEST_MSG = 16,
        WIRE_TEST_TLV3 = 4,
        WIRE_TEST_TLV1 = 2,
        WIRE_TEST_IFDEF = 100,
        WIRE_TEST_TLV2 = 3,
};

const char *test_type_name(int e);

struct test_short_id {
        u64 u64;
};
struct test_features {
        u8 *localfeatures;
        u8 *globalfeatures;
};
struct subtype_var_assign {
        /*  variable length set of assignables (helper) */
        u16 *field_1;
};
struct subtype_varsize_struct {
        struct test_features field_0;
};
struct subtype_arrays {
        u8 field1[2];
        u16 field2[2];
        struct test_short_id field3[2];
};
struct subtype_varlen_varsize {
        /*  variable length set of variable size structs */
        struct test_features **field_1;
};
struct subtype_nested {
        struct test_short_id field_1;
};
struct subtype_var_len {
        struct test_short_id *field_2;
};
struct tlv_test_n3_tlv3 {
        struct test_short_id subtype;
        struct subtype_var_len varlen_subtype;
        struct subtype_var_assign varlen_assigned;
        struct subtype_varlen_varsize test_sbt_varlen_varsize;
        /*  array assigtest_nable */
        u32 arr_assign[2];
        /*  array structs */
        struct test_short_id arr_struct[2];
        /*  varletest_n assignable (helper) */
        u8 *localfeatures;
        /*  varletest_n assignable (no-helper) */
        u64 *varlen_ass;
        /*  varletest_n structs */
        struct test_short_id *varlen_struct;
        /*  varletest_n varsized structs */
        struct test_features **varlen_varsize;
        /*  implicit length */
        u8 *remainder;
};
struct tlv_test_n1_tlv1 {
        /*  a truncated u64 */
        u64 amount_msat;
};
struct tlv_test_n1_tlv2 {
        /*  neseted subtype */
        struct test_short_id scid;
};
struct tlv_test_n1_tlv3 {
        struct test_features features;
        struct amount_msat amount_msat_1;
        struct amount_msat amount_msat_2;
};
struct tlv_test_n1_tlv4 {
        u16 cltv_delta;
};
struct tlv_test_n2_tlv1 {
        u64 amount_msat;
};
struct tlv_test_n2_tlv2 {
        u32 cltv_expiry;
};
struct tlv_test_n3 {
        /* Raw fields including unknown ones. */
        struct tlv_field *fields;

	/* TODO The following explicit fields could just point into the
	 * tlv_field entries above to save on memory. */
        struct tlv_test_n3_tlv3 *tlv3;
};
struct tlv_test_n1 {
        /* Raw fields including unknown ones. */
        struct tlv_field *fields;

	/* TODO The following explicit fields could just point into the
	 * tlv_field entries above to save on memory. */
        struct tlv_test_n1_tlv1 *tlv1;
        struct tlv_test_n1_tlv2 *tlv2;
        struct tlv_test_n1_tlv3 *tlv3;
        struct tlv_test_n1_tlv4 *tlv4;
};
struct tlv_test_n2 {
        /* Raw fields including unknown ones. */
        struct tlv_field *fields;

	/* TODO The following explicit fields could just point into the
	 * tlv_field entries above to save on memory. */
        struct tlv_test_n2_tlv1 *tlv1;
        struct tlv_test_n2_tlv2 *tlv2;
};

struct tlv_test_n3 *tlv_test_n3_new(const tal_t *ctx);

/**
 * Deserialize a TLV stream for the test_n3 namespace.
 *
 * This function will parse any TLV stream, as long as the type, length and
 * value fields are formatted correctly. Fields that are not known in the
 * current namespace are stored in the `fields` member. Validity can be
 * checked using test_n3_is_valid.
 */
bool fromwire_test_n3(const u8 **cursor, size_t *max,
			  struct tlv_test_n3 * record);

/**
 * Serialize a TLV stream for the test_n3 namespace.
 *
 * This function only considers known fields from the test_n3 namespace,
 * and will ignore any fields that may be stored in the `fields` member. This
 * ensures that the resulting stream is valid according to
 * `test_n3_is_valid`.
 */
void towire_test_n3(u8 **pptr, const void *record);

/**
 * Check that the TLV stream is valid.
 *
 * Enforces the followin validity rules:
 * - Types must be in monotonic non-repeating order
 * - We must understand all even types
 *
 * Returns false if an error was detected, otherwise returns true. If err_index
 * is non-null and we detect an error it is set to the index of the first error
 * detected.
 */
bool test_n3_is_valid(const struct tlv_test_n3 *record,
			  size_t *err_index);

struct tlv_test_n1 *tlv_test_n1_new(const tal_t *ctx);

/**
 * Deserialize a TLV stream for the test_n1 namespace.
 *
 * This function will parse any TLV stream, as long as the type, length and
 * value fields are formatted correctly. Fields that are not known in the
 * current namespace are stored in the `fields` member. Validity can be
 * checked using test_n1_is_valid.
 */
bool fromwire_test_n1(const u8 **cursor, size_t *max,
			  struct tlv_test_n1 * record);

/**
 * Serialize a TLV stream for the test_n1 namespace.
 *
 * This function only considers known fields from the test_n1 namespace,
 * and will ignore any fields that may be stored in the `fields` member. This
 * ensures that the resulting stream is valid according to
 * `test_n1_is_valid`.
 */
void towire_test_n1(u8 **pptr, const void *record);

/**
 * Check that the TLV stream is valid.
 *
 * Enforces the followin validity rules:
 * - Types must be in monotonic non-repeating order
 * - We must understand all even types
 *
 * Returns false if an error was detected, otherwise returns true. If err_index
 * is non-null and we detect an error it is set to the index of the first error
 * detected.
 */
bool test_n1_is_valid(const struct tlv_test_n1 *record,
			  size_t *err_index);

struct tlv_test_n2 *tlv_test_n2_new(const tal_t *ctx);

/**
 * Deserialize a TLV stream for the test_n2 namespace.
 *
 * This function will parse any TLV stream, as long as the type, length and
 * value fields are formatted correctly. Fields that are not known in the
 * current namespace are stored in the `fields` member. Validity can be
 * checked using test_n2_is_valid.
 */
bool fromwire_test_n2(const u8 **cursor, size_t *max,
			  struct tlv_test_n2 * record);

/**
 * Serialize a TLV stream for the test_n2 namespace.
 *
 * This function only considers known fields from the test_n2 namespace,
 * and will ignore any fields that may be stored in the `fields` member. This
 * ensures that the resulting stream is valid according to
 * `test_n2_is_valid`.
 */
void towire_test_n2(u8 **pptr, const void *record);

/**
 * Check that the TLV stream is valid.
 *
 * Enforces the followin validity rules:
 * - Types must be in monotonic non-repeating order
 * - We must understand all even types
 *
 * Returns false if an error was detected, otherwise returns true. If err_index
 * is non-null and we detect an error it is set to the index of the first error
 * detected.
 */
bool test_n2_is_valid(const struct tlv_test_n2 *record,
			  size_t *err_index);

/* WIRE: TEST_MSG */
/*  omnibus method */
u8 *towire_test_msg(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays);
bool fromwire_test_msg(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays);

/* WIRE: TEST_TLV3 */
u8 *towire_test_tlv3(const tal_t *ctx, const struct tlv_test_n3 *tlv);
bool fromwire_test_tlv3(const void *p, struct tlv_test_n3 *tlv);

/* WIRE: TEST_TLV1 */
u8 *towire_test_tlv1(const tal_t *ctx, const struct test_short_id *test_struct, const struct tlv_test_n1 *tlv);
bool fromwire_test_tlv1(const void *p, struct test_short_id *test_struct, struct tlv_test_n1 *tlv);

#if TEST_IFDEF
/* WIRE: TEST_IFDEF */
u8 *towire_test_ifdef(const tal_t *ctx, u32 is_def);
bool fromwire_test_ifdef(const void *p, u32 *is_def);
#endif /* TEST_IFDEF */

/* WIRE: TEST_TLV2 */
u8 *towire_test_tlv2(const tal_t *ctx, const struct tlv_test_n2 *tlv);
bool fromwire_test_tlv2(const void *p, struct tlv_test_n2 *tlv);

/* WIRE: TEST_MSG_OPTION_SHORT_ID */
/*  omnibus method */
u8 *towire_test_msg_option_short_id(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_features *extension_1);
bool fromwire_test_msg_option_short_id(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_features **extension_1);

/* WIRE: TEST_MSG_OPTION_TWO */
/*  omnibus method */
u8 *towire_test_msg_option_two(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_short_id *extension_2);
bool fromwire_test_msg_option_two(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_short_id *extension_2);

/* WIRE: TEST_MSG_OPTION_ONE */
/*  omnibus method */
u8 *towire_test_msg_option_one(const tal_t *ctx, const u8 test_arr_u8[10], const u16 test_arr_assignable[5], const u8 *test_var_len_u8_arr, const u32 *test_var_len_ass_arr, const struct test_short_id test_struct_arr[10], const struct test_short_id *test_struct_varlen, const struct test_features **test_varsize_struct_varlen, u16 test_assignable, enum test_enum test_enum, const struct test_short_id *test_struct, const struct test_features *test_varsize_struct, u32 *test_optional_assignable, const struct test_short_id *test_optional_struct, const struct test_features *test_optional_varsize_struct, const struct subtype_nested *test_sbt_struct_nested, const struct subtype_varsize_struct *test_sbt_varsize_struct, const struct subtype_var_assign *test_sbt_varsize_var_assign, const struct subtype_var_len *test_sbt_var_len, const struct subtype_varlen_varsize *test_sbt_varlen_varsize, const struct subtype_arrays *test_sbt_arrays, const struct test_short_id *extension_2);
bool fromwire_test_msg_option_one(const tal_t *ctx, const void *p, u8 test_arr_u8[10], u16 test_arr_assignable[5], u8 **test_var_len_u8_arr, u32 **test_var_len_ass_arr, struct test_short_id test_struct_arr[10], struct test_short_id **test_struct_varlen, struct test_features ***test_varsize_struct_varlen, u16 *test_assignable, enum test_enum *test_enum, struct test_short_id *test_struct, struct test_features **test_varsize_struct, u32 **test_optional_assignable, struct test_short_id **test_optional_struct, struct test_features **test_optional_varsize_struct, struct subtype_nested *test_sbt_struct_nested, struct subtype_varsize_struct *test_sbt_varsize_struct, struct subtype_var_assign **test_sbt_varsize_var_assign, struct subtype_var_len **test_sbt_var_len, struct subtype_varlen_varsize **test_sbt_varlen_varsize, struct subtype_arrays *test_sbt_arrays, struct test_short_id *extension_2);


#endif /* LIGHTNING_TOOLS_TEST_GEN_TEST_H */

