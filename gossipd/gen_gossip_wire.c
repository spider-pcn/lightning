/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <gossipd/gen_gossip_wire.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *gossip_wire_type_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum gossip_wire_type)e) {
	case WIRE_GOSSIP_GETROUTE_REQUEST: return "WIRE_GOSSIP_GETROUTE_REQUEST";
	case WIRE_GOSSIP_GETNODES_REQUEST: return "WIRE_GOSSIP_GETNODES_REQUEST";
	case WIRE_GOSSIP_NEW_BLOCKHEIGHT: return "WIRE_GOSSIP_NEW_BLOCKHEIGHT";
	case WIRE_GOSSIP_GET_INCOMING_CHANNELS_REPLY: return "WIRE_GOSSIP_GET_INCOMING_CHANNELS_REPLY";
	case WIRE_GOSSIP_DEV_SET_TIME: return "WIRE_GOSSIP_DEV_SET_TIME";
	case WIRE_GOSSIP_OUTPOINT_SPENT: return "WIRE_GOSSIP_OUTPOINT_SPENT";
	case WIRE_GOSSIP_DEV_COMPACT_STORE: return "WIRE_GOSSIP_DEV_COMPACT_STORE";
	case WIRE_GOSSIP_DEV_MEMLEAK: return "WIRE_GOSSIP_DEV_MEMLEAK";
	case WIRE_GOSSIP_GET_CHANNEL_PEER_REPLY: return "WIRE_GOSSIP_GET_CHANNEL_PEER_REPLY";
	case WIRE_GOSSIP_PING_REPLY: return "WIRE_GOSSIP_PING_REPLY";
	case WIRE_GOSSIPCTL_INIT: return "WIRE_GOSSIPCTL_INIT";
	case WIRE_GOSSIP_DEV_SUPPRESS: return "WIRE_GOSSIP_DEV_SUPPRESS";
	case WIRE_GOSSIP_GETNODES_REPLY: return "WIRE_GOSSIP_GETNODES_REPLY";
	case WIRE_GOSSIP_PING: return "WIRE_GOSSIP_PING";
	case WIRE_GOSSIP_PAYMENT_FAILURE: return "WIRE_GOSSIP_PAYMENT_FAILURE";
	case WIRE_GOSSIP_GET_TXOUT_REPLY: return "WIRE_GOSSIP_GET_TXOUT_REPLY";
	case WIRE_GOSSIP_DEV_MEMLEAK_REPLY: return "WIRE_GOSSIP_DEV_MEMLEAK_REPLY";
	case WIRE_GOSSIP_GET_INCOMING_CHANNELS: return "WIRE_GOSSIP_GET_INCOMING_CHANNELS";
	case WIRE_GOSSIP_GETROUTE_REPLY: return "WIRE_GOSSIP_GETROUTE_REPLY";
	case WIRE_GOSSIP_GET_TXOUT: return "WIRE_GOSSIP_GET_TXOUT";
	case WIRE_GOSSIP_GETCHANNELS_REQUEST: return "WIRE_GOSSIP_GETCHANNELS_REQUEST";
	case WIRE_GOSSIP_GET_CHANNEL_PEER: return "WIRE_GOSSIP_GET_CHANNEL_PEER";
	case WIRE_GOSSIP_DEV_SET_MAX_SCIDS_ENCODE_SIZE: return "WIRE_GOSSIP_DEV_SET_MAX_SCIDS_ENCODE_SIZE";
	case WIRE_GOSSIP_DEV_COMPACT_STORE_REPLY: return "WIRE_GOSSIP_DEV_COMPACT_STORE_REPLY";
	case WIRE_GOSSIP_GETCHANNELS_REPLY: return "WIRE_GOSSIP_GETCHANNELS_REPLY";
	case WIRE_GOSSIP_LOCAL_CHANNEL_CLOSE: return "WIRE_GOSSIP_LOCAL_CHANNEL_CLOSE";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}




/* WIRE: GOSSIP_GETROUTE_REQUEST */
/* Pass JSON-RPC getroute call through */
u8 *towire_gossip_getroute_request(const tal_t *ctx, const struct node_id *source, const struct node_id *destination, struct amount_msat msatoshi, u64 riskfactor_by_million, u32 final_cltv, const double *fuzz, const struct exclude_entry **excluded, u32 max_hops)
{
	u16 num_excluded = tal_count(excluded);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETROUTE_REQUEST);
	/* Source defaults to "us" */
	if (!source)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_node_id(&p, source);
	}
	towire_node_id(&p, destination);
	towire_amount_msat(&p, msatoshi);
	/* We don't pass doubles */
	towire_u64(&p, riskfactor_by_million);
	towire_u32(&p, final_cltv);
	towire_double(&p, fuzz);
	towire_u16(&p, num_excluded);
	for (size_t i = 0; i < num_excluded; i++)
		towire_exclude_entry(&p, excluded[i]);
	towire_u32(&p, max_hops);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getroute_request(const tal_t *ctx, const void *p, struct node_id **source, struct node_id *destination, struct amount_msat *msatoshi, u64 *riskfactor_by_million, u32 *final_cltv, double *fuzz, struct exclude_entry ***excluded, u32 *max_hops)
{
	u16 num_excluded;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETROUTE_REQUEST)
		return false;
 	/* Source defaults to "us" */
	if (!fromwire_bool(&cursor, &plen))
		*source = NULL;
	else {
		*source = tal(ctx, struct node_id);
		fromwire_node_id(&cursor, &plen, *source);
	}
 	fromwire_node_id(&cursor, &plen, destination);
 	*msatoshi = fromwire_amount_msat(&cursor, &plen);
 	/* We don't pass doubles */
	*riskfactor_by_million = fromwire_u64(&cursor, &plen);
 	*final_cltv = fromwire_u32(&cursor, &plen);
 	fromwire_double(&cursor, &plen, fuzz);
 	num_excluded = fromwire_u16(&cursor, &plen);
 	// 2nd case excluded
	*excluded = num_excluded ? tal_arr(ctx, struct exclude_entry *, num_excluded) : NULL;
	for (size_t i = 0; i < num_excluded; i++)
		(*excluded)[i] = fromwire_exclude_entry(*excluded, &cursor, &plen);
 	*max_hops = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GETNODES_REQUEST */
/* Pass JSON-RPC getnodes call through */
u8 *towire_gossip_getnodes_request(const tal_t *ctx, const struct node_id *id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETNODES_REQUEST);
	if (!id)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_node_id(&p, id);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getnodes_request(const tal_t *ctx, const void *p, struct node_id **id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETNODES_REQUEST)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*id = NULL;
	else {
		*id = tal(ctx, struct node_id);
		fromwire_node_id(&cursor, &plen, *id);
	}
	return cursor != NULL;
}

/* WIRE: GOSSIP_NEW_BLOCKHEIGHT */
/* master -> gossipd: blockheight increased. */
u8 *towire_gossip_new_blockheight(const tal_t *ctx, u32 blockheight)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_NEW_BLOCKHEIGHT);
	towire_u32(&p, blockheight);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_new_blockheight(const void *p, u32 *blockheight)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_NEW_BLOCKHEIGHT)
		return false;
 	*blockheight = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_INCOMING_CHANNELS_REPLY */
/* gossipd -> master: here they are. */
u8 *towire_gossip_get_incoming_channels_reply(const tal_t *ctx, const struct route_info *route_info)
{
	u16 num = tal_count(route_info);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_INCOMING_CHANNELS_REPLY);
	towire_u16(&p, num);
	for (size_t i = 0; i < num; i++)
		towire_route_info(&p, route_info + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_incoming_channels_reply(const tal_t *ctx, const void *p, struct route_info **route_info)
{
	u16 num;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_INCOMING_CHANNELS_REPLY)
		return false;
 	num = fromwire_u16(&cursor, &plen);
 	// 2nd case route_info
	*route_info = num ? tal_arr(ctx, struct route_info, num) : NULL;
	for (size_t i = 0; i < num; i++)
		fromwire_route_info(&cursor, &plen, *route_info + i);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_SET_TIME */
/* In developer mode */
u8 *towire_gossip_dev_set_time(const tal_t *ctx, u32 dev_gossip_time)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_SET_TIME);
	towire_u32(&p, dev_gossip_time);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_set_time(const void *p, u32 *dev_gossip_time)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_SET_TIME)
		return false;
 	*dev_gossip_time = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_OUTPOINT_SPENT */
/* master -> gossipd: a potential funding outpoint was spent */
u8 *towire_gossip_outpoint_spent(const tal_t *ctx, const struct short_channel_id *short_channel_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_OUTPOINT_SPENT);
	towire_short_channel_id(&p, short_channel_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_outpoint_spent(const void *p, struct short_channel_id *short_channel_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_OUTPOINT_SPENT)
		return false;
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_COMPACT_STORE */
/* master -> gossipd: please rewrite the gossip_store */
u8 *towire_gossip_dev_compact_store(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_COMPACT_STORE);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_compact_store(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_COMPACT_STORE)
		return false;
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_MEMLEAK */
/* master -> gossipd: do you have a memleak? */
u8 *towire_gossip_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_CHANNEL_PEER_REPLY */
u8 *towire_gossip_get_channel_peer_reply(const tal_t *ctx, const struct node_id *peer_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_CHANNEL_PEER_REPLY);
	if (!peer_id)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_node_id(&p, peer_id);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_channel_peer_reply(const tal_t *ctx, const void *p, struct node_id **peer_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_CHANNEL_PEER_REPLY)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*peer_id = NULL;
	else {
		*peer_id = tal(ctx, struct node_id);
		fromwire_node_id(&cursor, &plen, *peer_id);
	}
	return cursor != NULL;
}

/* WIRE: GOSSIP_PING_REPLY */
u8 *towire_gossip_ping_reply(const tal_t *ctx, const struct node_id *id, bool sent, u16 totlen)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_PING_REPLY);
	towire_node_id(&p, id);
	/* False if id in gossip_ping was unknown. */
	towire_bool(&p, sent);
	/* 0 == no pong expected */
	towire_u16(&p, totlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_ping_reply(const void *p, struct node_id *id, bool *sent, u16 *totlen)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_PING_REPLY)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
 	/* False if id in gossip_ping was unknown. */
	*sent = fromwire_bool(&cursor, &plen);
 	/* 0 == no pong expected */
	*totlen = fromwire_u16(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIPCTL_INIT */
/* Initialize the gossip daemon. */
u8 *towire_gossipctl_init(const tal_t *ctx, const struct chainparams *chainparams, const struct node_id *id, const u8 *globalfeatures, const u8 rgb[3], const u8 alias[32], const struct wireaddr *announcable, u32 *dev_gossip_time, bool dev_fast_gossip, bool dev_fast_gossip_prune)
{
	u16 num_announcable = tal_count(announcable);
	u16 gflen = tal_count(globalfeatures);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIPCTL_INIT);
	towire_chainparams(&p, chainparams);
	towire_node_id(&p, id);
	towire_u16(&p, gflen);
	towire_u8_array(&p, globalfeatures, gflen);
	towire_u8_array(&p, rgb, 3);
	towire_u8_array(&p, alias, 32);
	towire_u16(&p, num_announcable);
	for (size_t i = 0; i < num_announcable; i++)
		towire_wireaddr(&p, announcable + i);
	if (!dev_gossip_time)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_u32(&p, *dev_gossip_time);
	}
	towire_bool(&p, dev_fast_gossip);
	towire_bool(&p, dev_fast_gossip_prune);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossipctl_init(const tal_t *ctx, const void *p, const struct chainparams **chainparams, struct node_id *id, u8 **globalfeatures, u8 rgb[3], u8 alias[32], struct wireaddr **announcable, u32 **dev_gossip_time, bool *dev_fast_gossip, bool *dev_fast_gossip_prune)
{
	u16 num_announcable;
	u16 gflen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIPCTL_INIT)
		return false;
 	fromwire_chainparams(&cursor, &plen, chainparams);
 	fromwire_node_id(&cursor, &plen, id);
 	gflen = fromwire_u16(&cursor, &plen);
 	// 2nd case globalfeatures
	*globalfeatures = gflen ? tal_arr(ctx, u8, gflen) : NULL;
	fromwire_u8_array(&cursor, &plen, *globalfeatures, gflen);
 	fromwire_u8_array(&cursor, &plen, rgb, 3);
 	fromwire_u8_array(&cursor, &plen, alias, 32);
 	num_announcable = fromwire_u16(&cursor, &plen);
 	// 2nd case announcable
	*announcable = num_announcable ? tal_arr(ctx, struct wireaddr, num_announcable) : NULL;
	for (size_t i = 0; i < num_announcable; i++)
		fromwire_wireaddr(&cursor, &plen, *announcable + i);
 	if (!fromwire_bool(&cursor, &plen))
		*dev_gossip_time = NULL;
	else {
		*dev_gossip_time = tal(ctx, u32);
		**dev_gossip_time = fromwire_u32(&cursor, &plen);
	}
 	*dev_fast_gossip = fromwire_bool(&cursor, &plen);
 	*dev_fast_gossip_prune = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_SUPPRESS */
/* master -> gossipd: stop gossip timers. */
u8 *towire_gossip_dev_suppress(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_SUPPRESS);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_suppress(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_SUPPRESS)
		return false;
	return cursor != NULL;
}

/* WIRE: GOSSIP_GETNODES_REPLY */
u8 *towire_gossip_getnodes_reply(const tal_t *ctx, const struct gossip_getnodes_entry **nodes)
{
	u32 num_nodes = tal_count(nodes);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETNODES_REPLY);
	towire_u32(&p, num_nodes);
	for (size_t i = 0; i < num_nodes; i++)
		towire_gossip_getnodes_entry(&p, nodes[i]);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getnodes_reply(const tal_t *ctx, const void *p, struct gossip_getnodes_entry ***nodes)
{
	u32 num_nodes;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETNODES_REPLY)
		return false;
 	num_nodes = fromwire_u32(&cursor, &plen);
 	// 2nd case nodes
	*nodes = num_nodes ? tal_arr(ctx, struct gossip_getnodes_entry *, num_nodes) : NULL;
	for (size_t i = 0; i < num_nodes; i++)
		(*nodes)[i] = fromwire_gossip_getnodes_entry(*nodes, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_PING */
/* Ping/pong test.  Waits for a reply if it expects one. */
u8 *towire_gossip_ping(const tal_t *ctx, const struct node_id *id, u16 num_pong_bytes, u16 len)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_PING);
	towire_node_id(&p, id);
	towire_u16(&p, num_pong_bytes);
	towire_u16(&p, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_ping(const void *p, struct node_id *id, u16 *num_pong_bytes, u16 *len)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_PING)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
 	*num_pong_bytes = fromwire_u16(&cursor, &plen);
 	*len = fromwire_u16(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_PAYMENT_FAILURE */
/* master->gossipd an htlc failed with this onion error. */
u8 *towire_gossip_payment_failure(const tal_t *ctx, const struct node_id *erring_node, const struct short_channel_id *erring_channel, u8 erring_channel_direction, const u8 *error)
{
	u16 len = tal_count(error);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_PAYMENT_FAILURE);
	towire_node_id(&p, erring_node);
	towire_short_channel_id(&p, erring_channel);
	towire_u8(&p, erring_channel_direction);
	towire_u16(&p, len);
	towire_u8_array(&p, error, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_payment_failure(const tal_t *ctx, const void *p, struct node_id *erring_node, struct short_channel_id *erring_channel, u8 *erring_channel_direction, u8 **error)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_PAYMENT_FAILURE)
		return false;
 	fromwire_node_id(&cursor, &plen, erring_node);
 	fromwire_short_channel_id(&cursor, &plen, erring_channel);
 	*erring_channel_direction = fromwire_u8(&cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case error
	*error = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *error, len);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_TXOUT_REPLY */
/* master->gossipd here is the output */
u8 *towire_gossip_get_txout_reply(const tal_t *ctx, const struct short_channel_id *short_channel_id, struct amount_sat satoshis, const u8 *outscript)
{
	u16 len = tal_count(outscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_TXOUT_REPLY);
	towire_short_channel_id(&p, short_channel_id);
	towire_amount_sat(&p, satoshis);
	towire_u16(&p, len);
	towire_u8_array(&p, outscript, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_txout_reply(const tal_t *ctx, const void *p, struct short_channel_id *short_channel_id, struct amount_sat *satoshis, u8 **outscript)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_TXOUT_REPLY)
		return false;
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
 	*satoshis = fromwire_amount_sat(&cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case outscript
	*outscript = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *outscript, len);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_MEMLEAK_REPLY */
u8 *towire_gossip_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_INCOMING_CHANNELS */
/* master -> gossipd: get route_info for our incoming channels */
u8 *towire_gossip_get_incoming_channels(const tal_t *ctx, bool *private_too)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_INCOMING_CHANNELS);
	if (!private_too)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_bool(&p, *private_too);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_incoming_channels(const tal_t *ctx, const void *p, bool **private_too)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_INCOMING_CHANNELS)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*private_too = NULL;
	else {
		*private_too = tal(ctx, bool);
		**private_too = fromwire_bool(&cursor, &plen);
	}
	return cursor != NULL;
}

/* WIRE: GOSSIP_GETROUTE_REPLY */
u8 *towire_gossip_getroute_reply(const tal_t *ctx, const struct route_hop *hops)
{
	u16 num_hops = tal_count(hops);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETROUTE_REPLY);
	towire_u16(&p, num_hops);
	for (size_t i = 0; i < num_hops; i++)
		towire_route_hop(&p, hops + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getroute_reply(const tal_t *ctx, const void *p, struct route_hop **hops)
{
	u16 num_hops;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETROUTE_REPLY)
		return false;
 	num_hops = fromwire_u16(&cursor, &plen);
 	// 2nd case hops
	*hops = num_hops ? tal_arr(ctx, struct route_hop, num_hops) : NULL;
	for (size_t i = 0; i < num_hops; i++)
		fromwire_route_hop(&cursor, &plen, *hops + i);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_TXOUT */
/* Gossipd->master get this tx output please. */
u8 *towire_gossip_get_txout(const tal_t *ctx, const struct short_channel_id *short_channel_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_TXOUT);
	towire_short_channel_id(&p, short_channel_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_txout(const void *p, struct short_channel_id *short_channel_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_TXOUT)
		return false;
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GETCHANNELS_REQUEST */
u8 *towire_gossip_getchannels_request(const tal_t *ctx, const struct short_channel_id *short_channel_id, const struct node_id *source, const struct short_channel_id *prev)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETCHANNELS_REQUEST);
	if (!short_channel_id)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_short_channel_id(&p, short_channel_id);
	}
	if (!source)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_node_id(&p, source);
	}
	if (!prev)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_short_channel_id(&p, prev);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getchannels_request(const tal_t *ctx, const void *p, struct short_channel_id **short_channel_id, struct node_id **source, struct short_channel_id **prev)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETCHANNELS_REQUEST)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*short_channel_id = NULL;
	else {
		*short_channel_id = tal(ctx, struct short_channel_id);
		fromwire_short_channel_id(&cursor, &plen, *short_channel_id);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*source = NULL;
	else {
		*source = tal(ctx, struct node_id);
		fromwire_node_id(&cursor, &plen, *source);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*prev = NULL;
	else {
		*prev = tal(ctx, struct short_channel_id);
		fromwire_short_channel_id(&cursor, &plen, *prev);
	}
	return cursor != NULL;
}

/* WIRE: GOSSIP_GET_CHANNEL_PEER */
/* Given a short_channel_id */
u8 *towire_gossip_get_channel_peer(const tal_t *ctx, const struct short_channel_id *channel_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GET_CHANNEL_PEER);
	towire_short_channel_id(&p, channel_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_get_channel_peer(const void *p, struct short_channel_id *channel_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GET_CHANNEL_PEER)
		return false;
 	fromwire_short_channel_id(&cursor, &plen, channel_id);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_SET_MAX_SCIDS_ENCODE_SIZE */
/* Set artificial maximum reply_channel_range size.  Master->gossipd */
u8 *towire_gossip_dev_set_max_scids_encode_size(const tal_t *ctx, u32 max)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_SET_MAX_SCIDS_ENCODE_SIZE);
	towire_u32(&p, max);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_set_max_scids_encode_size(const void *p, u32 *max)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_SET_MAX_SCIDS_ENCODE_SIZE)
		return false;
 	*max = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_DEV_COMPACT_STORE_REPLY */
/* gossipd -> master: ok */
u8 *towire_gossip_dev_compact_store_reply(const tal_t *ctx, bool success)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_DEV_COMPACT_STORE_REPLY);
	towire_bool(&p, success);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_dev_compact_store_reply(const void *p, bool *success)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_DEV_COMPACT_STORE_REPLY)
		return false;
 	*success = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_GETCHANNELS_REPLY */
u8 *towire_gossip_getchannels_reply(const tal_t *ctx, bool complete, const struct gossip_getchannels_entry **nodes)
{
	u32 num_channels = tal_count(nodes);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_GETCHANNELS_REPLY);
	towire_bool(&p, complete);
	towire_u32(&p, num_channels);
	for (size_t i = 0; i < num_channels; i++)
		towire_gossip_getchannels_entry(&p, nodes[i]);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_getchannels_reply(const tal_t *ctx, const void *p, bool *complete, struct gossip_getchannels_entry ***nodes)
{
	u32 num_channels;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_GETCHANNELS_REPLY)
		return false;
 	*complete = fromwire_bool(&cursor, &plen);
 	num_channels = fromwire_u32(&cursor, &plen);
 	// 2nd case nodes
	*nodes = num_channels ? tal_arr(ctx, struct gossip_getchannels_entry *, num_channels) : NULL;
	for (size_t i = 0; i < num_channels; i++)
		(*nodes)[i] = fromwire_gossip_getchannels_entry(*nodes, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIP_LOCAL_CHANNEL_CLOSE */
/* gossipd->master: we're closing this channel. */
u8 *towire_gossip_local_channel_close(const tal_t *ctx, const struct short_channel_id *short_channel_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_LOCAL_CHANNEL_CLOSE);
	towire_short_channel_id(&p, short_channel_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_local_channel_close(const void *p, struct short_channel_id *short_channel_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_LOCAL_CHANNEL_CLOSE)
		return false;
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
	return cursor != NULL;
}

