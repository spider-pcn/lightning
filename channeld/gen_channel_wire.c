/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <channeld/gen_channel_wire.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *channel_wire_type_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum channel_wire_type)e) {
	case WIRE_CHANNEL_INIT: return "WIRE_CHANNEL_INIT";
	case WIRE_CHANNEL_FEERATES: return "WIRE_CHANNEL_FEERATES";
	case WIRE_CHANNEL_GOT_REVOKE: return "WIRE_CHANNEL_GOT_REVOKE";
	case WIRE_CHANNEL_GOT_ANNOUNCEMENT: return "WIRE_CHANNEL_GOT_ANNOUNCEMENT";
	case WIRE_CHANNEL_SENDING_COMMITSIG_REPLY: return "WIRE_CHANNEL_SENDING_COMMITSIG_REPLY";
	case WIRE_CHANNEL_DEV_MEMLEAK: return "WIRE_CHANNEL_DEV_MEMLEAK";
	case WIRE_CHANNEL_SENDING_COMMITSIG: return "WIRE_CHANNEL_SENDING_COMMITSIG";
	case WIRE_CHANNEL_GOT_SHUTDOWN: return "WIRE_CHANNEL_GOT_SHUTDOWN";
	case WIRE_CHANNEL_OFFER_HTLC_REPLY: return "WIRE_CHANNEL_OFFER_HTLC_REPLY";
	case WIRE_CHANNEL_SEND_SHUTDOWN: return "WIRE_CHANNEL_SEND_SHUTDOWN";
	case WIRE_CHANNEL_GOT_COMMITSIG: return "WIRE_CHANNEL_GOT_COMMITSIG";
	case WIRE_CHANNEL_GOT_COMMITSIG_REPLY: return "WIRE_CHANNEL_GOT_COMMITSIG_REPLY";
	case WIRE_CHANNEL_SPECIFIC_FEERATES: return "WIRE_CHANNEL_SPECIFIC_FEERATES";
	case WIRE_CHANNEL_SHUTDOWN_COMPLETE: return "WIRE_CHANNEL_SHUTDOWN_COMPLETE";
	case WIRE_CHANNEL_SEND_ERROR: return "WIRE_CHANNEL_SEND_ERROR";
	case WIRE_CHANNEL_GOT_FUNDING_LOCKED: return "WIRE_CHANNEL_GOT_FUNDING_LOCKED";
	case WIRE_CHANNEL_FUNDING_DEPTH: return "WIRE_CHANNEL_FUNDING_DEPTH";
	case WIRE_CHANNEL_GOT_REVOKE_REPLY: return "WIRE_CHANNEL_GOT_REVOKE_REPLY";
	case WIRE_CHANNEL_FULFILL_HTLC: return "WIRE_CHANNEL_FULFILL_HTLC";
	case WIRE_CHANNEL_FAIL_HTLC: return "WIRE_CHANNEL_FAIL_HTLC";
	case WIRE_CHANNEL_DEV_REENABLE_COMMIT_REPLY: return "WIRE_CHANNEL_DEV_REENABLE_COMMIT_REPLY";
	case WIRE_CHANNEL_DEV_MEMLEAK_REPLY: return "WIRE_CHANNEL_DEV_MEMLEAK_REPLY";
	case WIRE_CHANNEL_OFFER_HTLC: return "WIRE_CHANNEL_OFFER_HTLC";
	case WIRE_CHANNEL_FAIL_FALLEN_BEHIND: return "WIRE_CHANNEL_FAIL_FALLEN_BEHIND";
	case WIRE_CHANNEL_DEV_REENABLE_COMMIT: return "WIRE_CHANNEL_DEV_REENABLE_COMMIT";
	case WIRE_CHANNEL_SEND_ERROR_REPLY: return "WIRE_CHANNEL_SEND_ERROR_REPLY";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}




/* WIRE: CHANNEL_INIT */
/* Begin!  (passes gossipd-client fd) */
u8 *towire_channel_init(const tal_t *ctx, const struct chainparams *chainparams, const struct bitcoin_txid *funding_txid, u16 funding_txout, struct amount_sat funding_satoshi, u32 minimum_depth, const struct channel_config *our_config, const struct channel_config *their_config, const struct fee_states *fee_states, u32 feerate_min, u32 feerate_max, const struct bitcoin_signature *first_commit_sig, const struct per_peer_state *per_peer_state, const struct pubkey *remote_fundingkey, const struct basepoints *remote_basepoints, const struct pubkey *remote_per_commit, const struct pubkey *old_remote_per_commit, enum side funder, u32 fee_base, u32 fee_proportional, struct amount_msat local_msatoshi, const struct basepoints *our_basepoints, const struct pubkey *our_funding_pubkey, const struct node_id *local_node_id, const struct node_id *remote_node_id, u32 commit_msec, u16 cltv_delta, bool last_was_revoke, const struct changed_htlc *last_sent_commit, u64 next_index_local, u64 next_index_remote, u64 revocations_received, u64 next_htlc_id, const struct added_htlc *htlcs, const enum htlc_state *htlc_states, const struct fulfilled_htlc *fulfilled, const enum side *fulfilled_sides, const struct failed_htlc **failed, const enum side *failed_sides, u32 failheight, bool local_funding_locked, bool remote_funding_locked, const struct short_channel_id *funding_short_id, bool reestablish, bool send_shutdown, bool remote_shutdown_received, const u8 *final_scriptpubkey, u8 flags, const u8 *init_peer_pkt, bool reached_announce_depth, const struct secret *last_remote_secret, const u8 *localfeatures, const u8 *upfront_shutdown_script, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig, bool option_static_remotekey, bool dev_fast_gossip)
{
	u16 lflen = tal_count(localfeatures);
	u16 num_fulfilled = tal_count(fulfilled_sides);
	u16 upfront_shutdown_script_len = tal_count(upfront_shutdown_script);
	u16 num_htlcs = tal_count(htlc_states);
	u16 init_peer_pkt_len = tal_count(init_peer_pkt);
	u16 num_last_sent_commit = tal_count(last_sent_commit);
	u16 final_scriptpubkey_len = tal_count(final_scriptpubkey);
	u16 num_failed = tal_count(failed_sides);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_INIT);
	towire_chainparams(&p, chainparams);
	towire_bitcoin_txid(&p, funding_txid);
	towire_u16(&p, funding_txout);
	towire_amount_sat(&p, funding_satoshi);
	towire_u32(&p, minimum_depth);
	towire_channel_config(&p, our_config);
	towire_channel_config(&p, their_config);
	towire_fee_states(&p, fee_states);
	towire_u32(&p, feerate_min);
	towire_u32(&p, feerate_max);
	towire_bitcoin_signature(&p, first_commit_sig);
	towire_per_peer_state(&p, per_peer_state);
	towire_pubkey(&p, remote_fundingkey);
	towire_basepoints(&p, remote_basepoints);
	towire_pubkey(&p, remote_per_commit);
	towire_pubkey(&p, old_remote_per_commit);
	towire_side(&p, funder);
	towire_u32(&p, fee_base);
	towire_u32(&p, fee_proportional);
	towire_amount_msat(&p, local_msatoshi);
	towire_basepoints(&p, our_basepoints);
	towire_pubkey(&p, our_funding_pubkey);
	towire_node_id(&p, local_node_id);
	towire_node_id(&p, remote_node_id);
	towire_u32(&p, commit_msec);
	towire_u16(&p, cltv_delta);
	towire_bool(&p, last_was_revoke);
	towire_u16(&p, num_last_sent_commit);
	for (size_t i = 0; i < num_last_sent_commit; i++)
		towire_changed_htlc(&p, last_sent_commit + i);
	towire_u64(&p, next_index_local);
	towire_u64(&p, next_index_remote);
	towire_u64(&p, revocations_received);
	towire_u64(&p, next_htlc_id);
	towire_u16(&p, num_htlcs);
	for (size_t i = 0; i < num_htlcs; i++)
		towire_added_htlc(&p, htlcs + i);
	for (size_t i = 0; i < num_htlcs; i++)
		towire_htlc_state(&p, htlc_states[i]);
	towire_u16(&p, num_fulfilled);
	for (size_t i = 0; i < num_fulfilled; i++)
		towire_fulfilled_htlc(&p, fulfilled + i);
	for (size_t i = 0; i < num_fulfilled; i++)
		towire_side(&p, fulfilled_sides[i]);
	towire_u16(&p, num_failed);
	for (size_t i = 0; i < num_failed; i++)
		towire_failed_htlc(&p, failed[i]);
	for (size_t i = 0; i < num_failed; i++)
		towire_side(&p, failed_sides[i]);
	towire_u32(&p, failheight);
	towire_bool(&p, local_funding_locked);
	towire_bool(&p, remote_funding_locked);
	towire_short_channel_id(&p, funding_short_id);
	towire_bool(&p, reestablish);
	towire_bool(&p, send_shutdown);
	towire_bool(&p, remote_shutdown_received);
	towire_u16(&p, final_scriptpubkey_len);
	towire_u8_array(&p, final_scriptpubkey, final_scriptpubkey_len);
	towire_u8(&p, flags);
	towire_u16(&p, init_peer_pkt_len);
	towire_u8_array(&p, init_peer_pkt, init_peer_pkt_len);
	towire_bool(&p, reached_announce_depth);
	towire_secret(&p, last_remote_secret);
	towire_u16(&p, lflen);
	towire_u8_array(&p, localfeatures, lflen);
	towire_u16(&p, upfront_shutdown_script_len);
	towire_u8_array(&p, upfront_shutdown_script, upfront_shutdown_script_len);
	if (!remote_ann_node_sig)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secp256k1_ecdsa_signature(&p, remote_ann_node_sig);
	}
	if (!remote_ann_bitcoin_sig)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secp256k1_ecdsa_signature(&p, remote_ann_bitcoin_sig);
	}
	towire_bool(&p, option_static_remotekey);
	towire_bool(&p, dev_fast_gossip);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_init(const tal_t *ctx, const void *p, const struct chainparams **chainparams, struct bitcoin_txid *funding_txid, u16 *funding_txout, struct amount_sat *funding_satoshi, u32 *minimum_depth, struct channel_config *our_config, struct channel_config *their_config, struct fee_states **fee_states, u32 *feerate_min, u32 *feerate_max, struct bitcoin_signature *first_commit_sig, struct per_peer_state **per_peer_state, struct pubkey *remote_fundingkey, struct basepoints *remote_basepoints, struct pubkey *remote_per_commit, struct pubkey *old_remote_per_commit, enum side *funder, u32 *fee_base, u32 *fee_proportional, struct amount_msat *local_msatoshi, struct basepoints *our_basepoints, struct pubkey *our_funding_pubkey, struct node_id *local_node_id, struct node_id *remote_node_id, u32 *commit_msec, u16 *cltv_delta, bool *last_was_revoke, struct changed_htlc **last_sent_commit, u64 *next_index_local, u64 *next_index_remote, u64 *revocations_received, u64 *next_htlc_id, struct added_htlc **htlcs, enum htlc_state **htlc_states, struct fulfilled_htlc **fulfilled, enum side **fulfilled_sides, struct failed_htlc ***failed, enum side **failed_sides, u32 *failheight, bool *local_funding_locked, bool *remote_funding_locked, struct short_channel_id *funding_short_id, bool *reestablish, bool *send_shutdown, bool *remote_shutdown_received, u8 **final_scriptpubkey, u8 *flags, u8 **init_peer_pkt, bool *reached_announce_depth, struct secret *last_remote_secret, u8 **localfeatures, u8 **upfront_shutdown_script, secp256k1_ecdsa_signature **remote_ann_node_sig, secp256k1_ecdsa_signature **remote_ann_bitcoin_sig, bool *option_static_remotekey, bool *dev_fast_gossip)
{
	u16 lflen;
	u16 num_fulfilled;
	u16 upfront_shutdown_script_len;
	u16 num_htlcs;
	u16 init_peer_pkt_len;
	u16 num_last_sent_commit;
	u16 final_scriptpubkey_len;
	u16 num_failed;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_INIT)
		return false;
 	fromwire_chainparams(&cursor, &plen, chainparams);
 	fromwire_bitcoin_txid(&cursor, &plen, funding_txid);
 	*funding_txout = fromwire_u16(&cursor, &plen);
 	*funding_satoshi = fromwire_amount_sat(&cursor, &plen);
 	*minimum_depth = fromwire_u32(&cursor, &plen);
 	fromwire_channel_config(&cursor, &plen, our_config);
 	fromwire_channel_config(&cursor, &plen, their_config);
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	*feerate_min = fromwire_u32(&cursor, &plen);
 	*feerate_max = fromwire_u32(&cursor, &plen);
 	fromwire_bitcoin_signature(&cursor, &plen, first_commit_sig);
 	*per_peer_state = fromwire_per_peer_state(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_fundingkey);
 	fromwire_basepoints(&cursor, &plen, remote_basepoints);
 	fromwire_pubkey(&cursor, &plen, remote_per_commit);
 	fromwire_pubkey(&cursor, &plen, old_remote_per_commit);
 	*funder = fromwire_side(&cursor, &plen);
 	*fee_base = fromwire_u32(&cursor, &plen);
 	*fee_proportional = fromwire_u32(&cursor, &plen);
 	*local_msatoshi = fromwire_amount_msat(&cursor, &plen);
 	fromwire_basepoints(&cursor, &plen, our_basepoints);
 	fromwire_pubkey(&cursor, &plen, our_funding_pubkey);
 	fromwire_node_id(&cursor, &plen, local_node_id);
 	fromwire_node_id(&cursor, &plen, remote_node_id);
 	*commit_msec = fromwire_u32(&cursor, &plen);
 	*cltv_delta = fromwire_u16(&cursor, &plen);
 	*last_was_revoke = fromwire_bool(&cursor, &plen);
 	num_last_sent_commit = fromwire_u16(&cursor, &plen);
 	// 2nd case last_sent_commit
	*last_sent_commit = num_last_sent_commit ? tal_arr(ctx, struct changed_htlc, num_last_sent_commit) : NULL;
	for (size_t i = 0; i < num_last_sent_commit; i++)
		fromwire_changed_htlc(&cursor, &plen, *last_sent_commit + i);
 	*next_index_local = fromwire_u64(&cursor, &plen);
 	*next_index_remote = fromwire_u64(&cursor, &plen);
 	*revocations_received = fromwire_u64(&cursor, &plen);
 	*next_htlc_id = fromwire_u64(&cursor, &plen);
 	num_htlcs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlcs
	*htlcs = num_htlcs ? tal_arr(ctx, struct added_htlc, num_htlcs) : NULL;
	for (size_t i = 0; i < num_htlcs; i++)
		fromwire_added_htlc(&cursor, &plen, *htlcs + i);
 	// 2nd case htlc_states
	*htlc_states = num_htlcs ? tal_arr(ctx, enum htlc_state, num_htlcs) : NULL;
	for (size_t i = 0; i < num_htlcs; i++)
		(*htlc_states)[i] = fromwire_htlc_state(&cursor, &plen);
 	num_fulfilled = fromwire_u16(&cursor, &plen);
 	// 2nd case fulfilled
	*fulfilled = num_fulfilled ? tal_arr(ctx, struct fulfilled_htlc, num_fulfilled) : NULL;
	for (size_t i = 0; i < num_fulfilled; i++)
		fromwire_fulfilled_htlc(&cursor, &plen, *fulfilled + i);
 	// 2nd case fulfilled_sides
	*fulfilled_sides = num_fulfilled ? tal_arr(ctx, enum side, num_fulfilled) : NULL;
	for (size_t i = 0; i < num_fulfilled; i++)
		(*fulfilled_sides)[i] = fromwire_side(&cursor, &plen);
 	num_failed = fromwire_u16(&cursor, &plen);
 	// 2nd case failed
	*failed = num_failed ? tal_arr(ctx, struct failed_htlc *, num_failed) : NULL;
	for (size_t i = 0; i < num_failed; i++)
		(*failed)[i] = fromwire_failed_htlc(*failed, &cursor, &plen);
 	// 2nd case failed_sides
	*failed_sides = num_failed ? tal_arr(ctx, enum side, num_failed) : NULL;
	for (size_t i = 0; i < num_failed; i++)
		(*failed_sides)[i] = fromwire_side(&cursor, &plen);
 	*failheight = fromwire_u32(&cursor, &plen);
 	*local_funding_locked = fromwire_bool(&cursor, &plen);
 	*remote_funding_locked = fromwire_bool(&cursor, &plen);
 	fromwire_short_channel_id(&cursor, &plen, funding_short_id);
 	*reestablish = fromwire_bool(&cursor, &plen);
 	*send_shutdown = fromwire_bool(&cursor, &plen);
 	*remote_shutdown_received = fromwire_bool(&cursor, &plen);
 	final_scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case final_scriptpubkey
	*final_scriptpubkey = final_scriptpubkey_len ? tal_arr(ctx, u8, final_scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *final_scriptpubkey, final_scriptpubkey_len);
 	*flags = fromwire_u8(&cursor, &plen);
 	init_peer_pkt_len = fromwire_u16(&cursor, &plen);
 	// 2nd case init_peer_pkt
	*init_peer_pkt = init_peer_pkt_len ? tal_arr(ctx, u8, init_peer_pkt_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *init_peer_pkt, init_peer_pkt_len);
 	*reached_announce_depth = fromwire_bool(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, last_remote_secret);
 	lflen = fromwire_u16(&cursor, &plen);
 	// 2nd case localfeatures
	*localfeatures = lflen ? tal_arr(ctx, u8, lflen) : NULL;
	fromwire_u8_array(&cursor, &plen, *localfeatures, lflen);
 	upfront_shutdown_script_len = fromwire_u16(&cursor, &plen);
 	// 2nd case upfront_shutdown_script
	*upfront_shutdown_script = upfront_shutdown_script_len ? tal_arr(ctx, u8, upfront_shutdown_script_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *upfront_shutdown_script, upfront_shutdown_script_len);
 	if (!fromwire_bool(&cursor, &plen))
		*remote_ann_node_sig = NULL;
	else {
		*remote_ann_node_sig = tal(ctx, secp256k1_ecdsa_signature);
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *remote_ann_node_sig);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*remote_ann_bitcoin_sig = NULL;
	else {
		*remote_ann_bitcoin_sig = tal(ctx, secp256k1_ecdsa_signature);
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *remote_ann_bitcoin_sig);
	}
 	*option_static_remotekey = fromwire_bool(&cursor, &plen);
 	*dev_fast_gossip = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_FEERATES */
u8 *towire_channel_feerates(const tal_t *ctx, u32 feerate, u32 min_feerate, u32 max_feerate)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_FEERATES);
	towire_u32(&p, feerate);
	towire_u32(&p, min_feerate);
	towire_u32(&p, max_feerate);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_feerates(const void *p, u32 *feerate, u32 *min_feerate, u32 *max_feerate)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_FEERATES)
		return false;
 	*feerate = fromwire_u32(&cursor, &plen);
 	*min_feerate = fromwire_u32(&cursor, &plen);
 	*max_feerate = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_REVOKE */
u8 *towire_channel_got_revoke(const tal_t *ctx, u64 revokenum, const struct secret *per_commitment_secret, const struct pubkey *next_per_commit_point, const struct fee_states *fee_states, const struct changed_htlc *changed)
{
	u16 num_changed = tal_count(changed);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_REVOKE);
	towire_u64(&p, revokenum);
	towire_secret(&p, per_commitment_secret);
	towire_pubkey(&p, next_per_commit_point);
	/* RCVD_ADD_ACK_REVOCATION */
	towire_fee_states(&p, fee_states);
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_revoke(const tal_t *ctx, const void *p, u64 *revokenum, struct secret *per_commitment_secret, struct pubkey *next_per_commit_point, struct fee_states **fee_states, struct changed_htlc **changed)
{
	u16 num_changed;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_REVOKE)
		return false;
 	*revokenum = fromwire_u64(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, per_commitment_secret);
 	fromwire_pubkey(&cursor, &plen, next_per_commit_point);
 	/* RCVD_ADD_ACK_REVOCATION */
	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_ANNOUNCEMENT */
/* When we receive announcement_signatures for channel announce */
u8 *towire_channel_got_announcement(const tal_t *ctx, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_ANNOUNCEMENT);
	towire_secp256k1_ecdsa_signature(&p, remote_ann_node_sig);
	towire_secp256k1_ecdsa_signature(&p, remote_ann_bitcoin_sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_announcement(const void *p, secp256k1_ecdsa_signature *remote_ann_node_sig, secp256k1_ecdsa_signature *remote_ann_bitcoin_sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_ANNOUNCEMENT)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, remote_ann_node_sig);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, remote_ann_bitcoin_sig);
	return cursor != NULL;
}

/* WIRE: CHANNEL_SENDING_COMMITSIG_REPLY */
/* Wait for reply */
u8 *towire_channel_sending_commitsig_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SENDING_COMMITSIG_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_sending_commitsig_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SENDING_COMMITSIG_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_DEV_MEMLEAK */
/* master -> channeld: do you have a memleak? */
u8 *towire_channel_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_SENDING_COMMITSIG */
/* When we send a commitment_signed message */
u8 *towire_channel_sending_commitsig(const tal_t *ctx, u64 commitnum, const struct fee_states *fee_states, const struct changed_htlc *changed, const struct bitcoin_signature *commit_sig, const secp256k1_ecdsa_signature *htlc_sigs)
{
	u16 num_changed = tal_count(changed);
	u16 num_htlc_sigs = tal_count(htlc_sigs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SENDING_COMMITSIG);
	towire_u64(&p, commitnum);
	towire_fee_states(&p, fee_states);
	/* SENT_ADD_COMMIT */
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);
	towire_bitcoin_signature(&p, commit_sig);
	towire_u16(&p, num_htlc_sigs);
	for (size_t i = 0; i < num_htlc_sigs; i++)
		towire_secp256k1_ecdsa_signature(&p, htlc_sigs + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_sending_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct fee_states **fee_states, struct changed_htlc **changed, struct bitcoin_signature *commit_sig, secp256k1_ecdsa_signature **htlc_sigs)
{
	u16 num_changed;
	u16 num_htlc_sigs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SENDING_COMMITSIG)
		return false;
 	*commitnum = fromwire_u64(&cursor, &plen);
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	/* SENT_ADD_COMMIT */
	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
 	fromwire_bitcoin_signature(&cursor, &plen, commit_sig);
 	num_htlc_sigs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_sigs
	*htlc_sigs = num_htlc_sigs ? tal_arr(ctx, secp256k1_ecdsa_signature, num_htlc_sigs) : NULL;
	for (size_t i = 0; i < num_htlc_sigs; i++)
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *htlc_sigs + i);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_SHUTDOWN */
/* Peer told us that channel is shutting down */
u8 *towire_channel_got_shutdown(const tal_t *ctx, const u8 *scriptpubkey)
{
	u16 scriptpubkey_len = tal_count(scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_SHUTDOWN);
	towire_u16(&p, scriptpubkey_len);
	towire_u8_array(&p, scriptpubkey, scriptpubkey_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_shutdown(const tal_t *ctx, const void *p, u8 **scriptpubkey)
{
	u16 scriptpubkey_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_SHUTDOWN)
		return false;
 	scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case scriptpubkey
	*scriptpubkey = scriptpubkey_len ? tal_arr(ctx, u8, scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *scriptpubkey, scriptpubkey_len);
	return cursor != NULL;
}

/* WIRE: CHANNEL_OFFER_HTLC_REPLY */
/* Reply; synchronous since IDs have to increment. */
u8 *towire_channel_offer_htlc_reply(const tal_t *ctx, u64 id, u16 failure_code, const u8 *failurestr)
{
	u16 failurestrlen = tal_count(failurestr);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_OFFER_HTLC_REPLY);
	towire_u64(&p, id);
	/* Zero failure code means success. */
	towire_u16(&p, failure_code);
	towire_u16(&p, failurestrlen);
	towire_u8_array(&p, failurestr, failurestrlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_offer_htlc_reply(const tal_t *ctx, const void *p, u64 *id, u16 *failure_code, u8 **failurestr)
{
	u16 failurestrlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_OFFER_HTLC_REPLY)
		return false;
 	*id = fromwire_u64(&cursor, &plen);
 	/* Zero failure code means success. */
	*failure_code = fromwire_u16(&cursor, &plen);
 	failurestrlen = fromwire_u16(&cursor, &plen);
 	// 2nd case failurestr
	*failurestr = failurestrlen ? tal_arr(ctx, u8, failurestrlen) : NULL;
	fromwire_u8_array(&cursor, &plen, *failurestr, failurestrlen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_SEND_SHUTDOWN */
/* Tell peer to shut down channel. */
u8 *towire_channel_send_shutdown(const tal_t *ctx, const u8 *shutdown_scriptpubkey)
{
	u16 shutdown_len = tal_count(shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SEND_SHUTDOWN);
	towire_u16(&p, shutdown_len);
	towire_u8_array(&p, shutdown_scriptpubkey, shutdown_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_send_shutdown(const tal_t *ctx, const void *p, u8 **shutdown_scriptpubkey)
{
	u16 shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SEND_SHUTDOWN)
		return false;
 	shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case shutdown_scriptpubkey
	*shutdown_scriptpubkey = shutdown_len ? tal_arr(ctx, u8, shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *shutdown_scriptpubkey, shutdown_len);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_COMMITSIG */
/* When we have a commitment_signed message */
u8 *towire_channel_got_commitsig(const tal_t *ctx, u64 commitnum, const struct fee_states *fee_states, const struct bitcoin_signature *signature, const secp256k1_ecdsa_signature *htlc_signature, const struct added_htlc *added, const struct secret *shared_secret, const struct fulfilled_htlc *fulfilled, const struct failed_htlc **failed, const struct changed_htlc *changed, const struct bitcoin_tx *tx)
{
	u16 num_changed = tal_count(changed);
	u16 num_fulfilled = tal_count(fulfilled);
	u16 num_added = tal_count(shared_secret);
	u16 num_failed = tal_count(failed);
	u16 num_htlcs = tal_count(htlc_signature);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_COMMITSIG);
	towire_u64(&p, commitnum);
	towire_fee_states(&p, fee_states);
	towire_bitcoin_signature(&p, signature);
	towire_u16(&p, num_htlcs);
	for (size_t i = 0; i < num_htlcs; i++)
		towire_secp256k1_ecdsa_signature(&p, htlc_signature + i);
	/* RCVD_ADD_COMMIT: we're now committed to their new offered HTLCs. */
	towire_u16(&p, num_added);
	for (size_t i = 0; i < num_added; i++)
		towire_added_htlc(&p, added + i);
	for (size_t i = 0; i < num_added; i++)
		towire_secret(&p, shared_secret + i);
	/* RCVD_REMOVE_COMMIT: we're now no longer committed to these HTLCs. */
	towire_u16(&p, num_fulfilled);
	for (size_t i = 0; i < num_fulfilled; i++)
		towire_fulfilled_htlc(&p, fulfilled + i);
	towire_u16(&p, num_failed);
	for (size_t i = 0; i < num_failed; i++)
		towire_failed_htlc(&p, failed[i]);
	/* RCVD_ADD_ACK_COMMIT */
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);
	towire_bitcoin_tx(&p, tx);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct fee_states **fee_states, struct bitcoin_signature *signature, secp256k1_ecdsa_signature **htlc_signature, struct added_htlc **added, struct secret **shared_secret, struct fulfilled_htlc **fulfilled, struct failed_htlc ***failed, struct changed_htlc **changed, struct bitcoin_tx **tx)
{
	u16 num_changed;
	u16 num_fulfilled;
	u16 num_added;
	u16 num_failed;
	u16 num_htlcs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_COMMITSIG)
		return false;
 	*commitnum = fromwire_u64(&cursor, &plen);
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	fromwire_bitcoin_signature(&cursor, &plen, signature);
 	num_htlcs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_signature
	*htlc_signature = num_htlcs ? tal_arr(ctx, secp256k1_ecdsa_signature, num_htlcs) : NULL;
	for (size_t i = 0; i < num_htlcs; i++)
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *htlc_signature + i);
 	/* RCVD_ADD_COMMIT: we're now committed to their new offered HTLCs. */
	num_added = fromwire_u16(&cursor, &plen);
 	// 2nd case added
	*added = num_added ? tal_arr(ctx, struct added_htlc, num_added) : NULL;
	for (size_t i = 0; i < num_added; i++)
		fromwire_added_htlc(&cursor, &plen, *added + i);
 	// 2nd case shared_secret
	*shared_secret = num_added ? tal_arr(ctx, struct secret, num_added) : NULL;
	for (size_t i = 0; i < num_added; i++)
		fromwire_secret(&cursor, &plen, *shared_secret + i);
 	/* RCVD_REMOVE_COMMIT: we're now no longer committed to these HTLCs. */
	num_fulfilled = fromwire_u16(&cursor, &plen);
 	// 2nd case fulfilled
	*fulfilled = num_fulfilled ? tal_arr(ctx, struct fulfilled_htlc, num_fulfilled) : NULL;
	for (size_t i = 0; i < num_fulfilled; i++)
		fromwire_fulfilled_htlc(&cursor, &plen, *fulfilled + i);
 	num_failed = fromwire_u16(&cursor, &plen);
 	// 2nd case failed
	*failed = num_failed ? tal_arr(ctx, struct failed_htlc *, num_failed) : NULL;
	for (size_t i = 0; i < num_failed; i++)
		(*failed)[i] = fromwire_failed_htlc(*failed, &cursor, &plen);
 	/* RCVD_ADD_ACK_COMMIT */
	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_COMMITSIG_REPLY */
/* Wait for reply */
u8 *towire_channel_got_commitsig_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_COMMITSIG_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_commitsig_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_COMMITSIG_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_SPECIFIC_FEERATES */
/* Handle a channel specific feerate base ppm configuration */
u8 *towire_channel_specific_feerates(const tal_t *ctx, u32 feerate_base, u32 feerate_ppm)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SPECIFIC_FEERATES);
	towire_u32(&p, feerate_base);
	towire_u32(&p, feerate_ppm);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_specific_feerates(const void *p, u32 *feerate_base, u32 *feerate_ppm)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SPECIFIC_FEERATES)
		return false;
 	*feerate_base = fromwire_u32(&cursor, &plen);
 	*feerate_ppm = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_SHUTDOWN_COMPLETE */
/* Shutdown is complete */
u8 *towire_channel_shutdown_complete(const tal_t *ctx, const struct per_peer_state *per_peer_state)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SHUTDOWN_COMPLETE);
	towire_per_peer_state(&p, per_peer_state);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_shutdown_complete(const tal_t *ctx, const void *p, struct per_peer_state **per_peer_state)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SHUTDOWN_COMPLETE)
		return false;
 	*per_peer_state = fromwire_per_peer_state(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_SEND_ERROR */
/* Ask channeld to send a error message. Used in forgetting channel case. */
u8 *towire_channel_send_error(const tal_t *ctx, const wirestring *reason)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SEND_ERROR);
	towire_wirestring(&p, reason);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_send_error(const tal_t *ctx, const void *p, wirestring **reason)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SEND_ERROR)
		return false;
 	*reason = fromwire_wirestring(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_FUNDING_LOCKED */
/* When we receive funding_locked. */
u8 *towire_channel_got_funding_locked(const tal_t *ctx, const struct pubkey *next_per_commit_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_FUNDING_LOCKED);
	towire_pubkey(&p, next_per_commit_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_funding_locked(const void *p, struct pubkey *next_per_commit_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_FUNDING_LOCKED)
		return false;
 	fromwire_pubkey(&cursor, &plen, next_per_commit_point);
	return cursor != NULL;
}

/* WIRE: CHANNEL_FUNDING_DEPTH */
/* master->channeld funding hit new depth(funding locked if >= lock depth) */
u8 *towire_channel_funding_depth(const tal_t *ctx, const struct short_channel_id *short_channel_id, u32 depth)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_FUNDING_DEPTH);
	if (!short_channel_id)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_short_channel_id(&p, short_channel_id);
	}
	towire_u32(&p, depth);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_funding_depth(const tal_t *ctx, const void *p, struct short_channel_id **short_channel_id, u32 *depth)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_FUNDING_DEPTH)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*short_channel_id = NULL;
	else {
		*short_channel_id = tal(ctx, struct short_channel_id);
		fromwire_short_channel_id(&cursor, &plen, *short_channel_id);
	}
 	*depth = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_GOT_REVOKE_REPLY */
/* Wait for reply */
/* (eg. if we sent another commitment_signed */
u8 *towire_channel_got_revoke_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_GOT_REVOKE_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_got_revoke_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_GOT_REVOKE_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_FULFILL_HTLC */
/* Main daemon found out the preimage for an HTLC */
u8 *towire_channel_fulfill_htlc(const tal_t *ctx, const struct fulfilled_htlc *fulfilled_htlc)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_FULFILL_HTLC);
	towire_fulfilled_htlc(&p, fulfilled_htlc);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_fulfill_htlc(const void *p, struct fulfilled_htlc *fulfilled_htlc)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_FULFILL_HTLC)
		return false;
 	fromwire_fulfilled_htlc(&cursor, &plen, fulfilled_htlc);
	return cursor != NULL;
}

/* WIRE: CHANNEL_FAIL_HTLC */
/* Main daemon says HTLC failed */
u8 *towire_channel_fail_htlc(const tal_t *ctx, const struct failed_htlc *failed_htlc, u32 failheight)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_FAIL_HTLC);
	towire_failed_htlc(&p, failed_htlc);
	towire_u32(&p, failheight);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_fail_htlc(const tal_t *ctx, const void *p, struct failed_htlc **failed_htlc, u32 *failheight)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_FAIL_HTLC)
		return false;
 	*failed_htlc = fromwire_failed_htlc(ctx, &cursor, &plen);
 	*failheight = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_DEV_REENABLE_COMMIT_REPLY */
u8 *towire_channel_dev_reenable_commit_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_DEV_REENABLE_COMMIT_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_dev_reenable_commit_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_DEV_REENABLE_COMMIT_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_DEV_MEMLEAK_REPLY */
u8 *towire_channel_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_OFFER_HTLC */
/* Tell channel to offer this htlc */
u8 *towire_channel_offer_htlc(const tal_t *ctx, struct amount_msat amount_msat, u32 cltv_expiry, const struct sha256 *payment_hash, const u8 onion_routing_packet[1366])
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_OFFER_HTLC);
	towire_amount_msat(&p, amount_msat);
	towire_u32(&p, cltv_expiry);
	towire_sha256(&p, payment_hash);
	towire_u8_array(&p, onion_routing_packet, 1366);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_offer_htlc(const void *p, struct amount_msat *amount_msat, u32 *cltv_expiry, struct sha256 *payment_hash, u8 onion_routing_packet[1366])
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_OFFER_HTLC)
		return false;
 	*amount_msat = fromwire_amount_msat(&cursor, &plen);
 	*cltv_expiry = fromwire_u32(&cursor, &plen);
 	fromwire_sha256(&cursor, &plen, payment_hash);
 	fromwire_u8_array(&cursor, &plen, onion_routing_packet, 1366);
	return cursor != NULL;
}

/* WIRE: CHANNEL_FAIL_FALLEN_BEHIND */
/* Peer presented proof it was from the future. */
u8 *towire_channel_fail_fallen_behind(const tal_t *ctx, const struct pubkey *remote_per_commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_FAIL_FALLEN_BEHIND);
	/* This is NULL if option_static_remotekey. */
	if (!remote_per_commitment_point)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, remote_per_commitment_point);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_fail_fallen_behind(const tal_t *ctx, const void *p, struct pubkey **remote_per_commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_FAIL_FALLEN_BEHIND)
		return false;
 	/* This is NULL if option_static_remotekey. */
	if (!fromwire_bool(&cursor, &plen))
		*remote_per_commitment_point = NULL;
	else {
		*remote_per_commitment_point = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *remote_per_commitment_point);
	}
	return cursor != NULL;
}

/* WIRE: CHANNEL_DEV_REENABLE_COMMIT */
/* Re-enable commit timer. */
u8 *towire_channel_dev_reenable_commit(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_DEV_REENABLE_COMMIT);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_dev_reenable_commit(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_DEV_REENABLE_COMMIT)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNEL_SEND_ERROR_REPLY */
/* Tell master channeld has sent the error message. */
u8 *towire_channel_send_error_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_SEND_ERROR_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_send_error_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_SEND_ERROR_REPLY)
		return false;
	return cursor != NULL;
}

