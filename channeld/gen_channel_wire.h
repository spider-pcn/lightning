/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/header_template */

#ifndef LIGHTNING_CHANNELD_GEN_CHANNEL_WIRE_H
#define LIGHTNING_CHANNELD_GEN_CHANNEL_WIRE_H
#include <ccan/tal/tal.h>
#include <wire/tlvstream.h>
#include <wire/wire.h>
#include <common/cryptomsg.h>
#include <common/channel_config.h>
#include <common/derive_basepoints.h>
#include <common/fee_states.h>
#include <common/per_peer_state.h>
#include <bitcoin/preimage.h>
#include <common/htlc_wire.h>

enum channel_wire_type {
        /*  Begin!  (passes gossipd-client fd) */
        WIRE_CHANNEL_INIT = 1000,
        /*  master->channeld funding hit new depth(funding locked if >= lock depth) */
        WIRE_CHANNEL_FUNDING_DEPTH = 1002,
        /*  Tell channel to offer this htlc */
        WIRE_CHANNEL_OFFER_HTLC = 1004,
        /*  Reply; synchronous since IDs have to increment. */
        WIRE_CHANNEL_OFFER_HTLC_REPLY = 1104,
        /*  Main daemon found out the preimage for an HTLC */
        WIRE_CHANNEL_FULFILL_HTLC = 1005,
        /*  Main daemon says HTLC failed */
        WIRE_CHANNEL_FAIL_HTLC = 1006,
        /*  When we receive funding_locked. */
        WIRE_CHANNEL_GOT_FUNDING_LOCKED = 1019,
        /*  When we send a commitment_signed message */
        WIRE_CHANNEL_SENDING_COMMITSIG = 1020,
        /*  Wait for reply */
        WIRE_CHANNEL_SENDING_COMMITSIG_REPLY = 1120,
        /*  When we have a commitment_signed message */
        WIRE_CHANNEL_GOT_COMMITSIG = 1021,
        /*  Wait for reply */
        WIRE_CHANNEL_GOT_COMMITSIG_REPLY = 1121,
        WIRE_CHANNEL_GOT_REVOKE = 1022,
        /*  Wait for reply */
        /*  (eg. if we sent another commitment_signed */
        WIRE_CHANNEL_GOT_REVOKE_REPLY = 1122,
        /*  Tell peer to shut down channel. */
        WIRE_CHANNEL_SEND_SHUTDOWN = 1023,
        /*  Peer told us that channel is shutting down */
        WIRE_CHANNEL_GOT_SHUTDOWN = 1024,
        /*  Shutdown is complete */
        WIRE_CHANNEL_SHUTDOWN_COMPLETE = 1025,
        /*  Re-enable commit timer. */
        WIRE_CHANNEL_DEV_REENABLE_COMMIT = 1026,
        WIRE_CHANNEL_DEV_REENABLE_COMMIT_REPLY = 1126,
        WIRE_CHANNEL_FEERATES = 1027,
        /*  master -> channeld: do you have a memleak? */
        WIRE_CHANNEL_DEV_MEMLEAK = 1033,
        WIRE_CHANNEL_DEV_MEMLEAK_REPLY = 1133,
        /*  Peer presented proof it was from the future. */
        WIRE_CHANNEL_FAIL_FALLEN_BEHIND = 1028,
        /*  Handle a channel specific feerate base ppm configuration */
        WIRE_CHANNEL_SPECIFIC_FEERATES = 1029,
        /*  When we receive announcement_signatures for channel announce */
        WIRE_CHANNEL_GOT_ANNOUNCEMENT = 1017,
        /*  Ask channeld to send a error message. Used in forgetting channel case. */
        WIRE_CHANNEL_SEND_ERROR = 1008,
        /*  Tell master channeld has sent the error message. */
        WIRE_CHANNEL_SEND_ERROR_REPLY = 1108,
};

const char *channel_wire_type_name(int e);


/* WIRE: CHANNEL_INIT */
/*  Begin!  (passes gossipd-client fd) */
u8 *towire_channel_init(const tal_t *ctx, const struct chainparams *chainparams, const struct bitcoin_txid *funding_txid, u16 funding_txout, struct amount_sat funding_satoshi, u32 minimum_depth, const struct channel_config *our_config, const struct channel_config *their_config, const struct fee_states *fee_states, u32 feerate_min, u32 feerate_max, const struct bitcoin_signature *first_commit_sig, const struct per_peer_state *per_peer_state, const struct pubkey *remote_fundingkey, const struct basepoints *remote_basepoints, const struct pubkey *remote_per_commit, const struct pubkey *old_remote_per_commit, enum side funder, u32 fee_base, u32 fee_proportional, struct amount_msat local_msatoshi, const struct basepoints *our_basepoints, const struct pubkey *our_funding_pubkey, const struct node_id *local_node_id, const struct node_id *remote_node_id, u32 commit_msec, u16 cltv_delta, bool last_was_revoke, const struct changed_htlc *last_sent_commit, u64 next_index_local, u64 next_index_remote, u64 revocations_received, u64 next_htlc_id, const struct added_htlc *htlcs, const enum htlc_state *htlc_states, const struct fulfilled_htlc *fulfilled, const enum side *fulfilled_sides, const struct failed_htlc **failed, const enum side *failed_sides, u32 failheight, bool local_funding_locked, bool remote_funding_locked, const struct short_channel_id *funding_short_id, bool reestablish, bool send_shutdown, bool remote_shutdown_received, const u8 *final_scriptpubkey, u8 flags, const u8 *init_peer_pkt, bool reached_announce_depth, const struct secret *last_remote_secret, const u8 *localfeatures, const u8 *upfront_shutdown_script, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig, bool option_static_remotekey, bool dev_fast_gossip);
bool fromwire_channel_init(const tal_t *ctx, const void *p, const struct chainparams **chainparams, struct bitcoin_txid *funding_txid, u16 *funding_txout, struct amount_sat *funding_satoshi, u32 *minimum_depth, struct channel_config *our_config, struct channel_config *their_config, struct fee_states **fee_states, u32 *feerate_min, u32 *feerate_max, struct bitcoin_signature *first_commit_sig, struct per_peer_state **per_peer_state, struct pubkey *remote_fundingkey, struct basepoints *remote_basepoints, struct pubkey *remote_per_commit, struct pubkey *old_remote_per_commit, enum side *funder, u32 *fee_base, u32 *fee_proportional, struct amount_msat *local_msatoshi, struct basepoints *our_basepoints, struct pubkey *our_funding_pubkey, struct node_id *local_node_id, struct node_id *remote_node_id, u32 *commit_msec, u16 *cltv_delta, bool *last_was_revoke, struct changed_htlc **last_sent_commit, u64 *next_index_local, u64 *next_index_remote, u64 *revocations_received, u64 *next_htlc_id, struct added_htlc **htlcs, enum htlc_state **htlc_states, struct fulfilled_htlc **fulfilled, enum side **fulfilled_sides, struct failed_htlc ***failed, enum side **failed_sides, u32 *failheight, bool *local_funding_locked, bool *remote_funding_locked, struct short_channel_id *funding_short_id, bool *reestablish, bool *send_shutdown, bool *remote_shutdown_received, u8 **final_scriptpubkey, u8 *flags, u8 **init_peer_pkt, bool *reached_announce_depth, struct secret *last_remote_secret, u8 **localfeatures, u8 **upfront_shutdown_script, secp256k1_ecdsa_signature **remote_ann_node_sig, secp256k1_ecdsa_signature **remote_ann_bitcoin_sig, bool *option_static_remotekey, bool *dev_fast_gossip);

/* WIRE: CHANNEL_FUNDING_DEPTH */
/*  master->channeld funding hit new depth(funding locked if >= lock depth) */
u8 *towire_channel_funding_depth(const tal_t *ctx, const struct short_channel_id *short_channel_id, u32 depth);
bool fromwire_channel_funding_depth(const tal_t *ctx, const void *p, struct short_channel_id **short_channel_id, u32 *depth);

/* WIRE: CHANNEL_OFFER_HTLC */
/*  Tell channel to offer this htlc */
u8 *towire_channel_offer_htlc(const tal_t *ctx, struct amount_msat amount_msat, u32 cltv_expiry, const struct sha256 *payment_hash, const u8 onion_routing_packet[1366]);
bool fromwire_channel_offer_htlc(const void *p, struct amount_msat *amount_msat, u32 *cltv_expiry, struct sha256 *payment_hash, u8 onion_routing_packet[1366]);

/* WIRE: CHANNEL_OFFER_HTLC_REPLY */
/*  Reply; synchronous since IDs have to increment. */
u8 *towire_channel_offer_htlc_reply(const tal_t *ctx, u64 id, u16 failure_code, const u8 *failurestr);
bool fromwire_channel_offer_htlc_reply(const tal_t *ctx, const void *p, u64 *id, u16 *failure_code, u8 **failurestr);

/* WIRE: CHANNEL_FULFILL_HTLC */
/*  Main daemon found out the preimage for an HTLC */
u8 *towire_channel_fulfill_htlc(const tal_t *ctx, const struct fulfilled_htlc *fulfilled_htlc);
bool fromwire_channel_fulfill_htlc(const void *p, struct fulfilled_htlc *fulfilled_htlc);

/* WIRE: CHANNEL_FAIL_HTLC */
/*  Main daemon says HTLC failed */
u8 *towire_channel_fail_htlc(const tal_t *ctx, const struct failed_htlc *failed_htlc, u32 failheight);
bool fromwire_channel_fail_htlc(const tal_t *ctx, const void *p, struct failed_htlc **failed_htlc, u32 *failheight);

/* WIRE: CHANNEL_GOT_FUNDING_LOCKED */
/*  When we receive funding_locked. */
u8 *towire_channel_got_funding_locked(const tal_t *ctx, const struct pubkey *next_per_commit_point);
bool fromwire_channel_got_funding_locked(const void *p, struct pubkey *next_per_commit_point);

/* WIRE: CHANNEL_SENDING_COMMITSIG */
/*  When we send a commitment_signed message */
u8 *towire_channel_sending_commitsig(const tal_t *ctx, u64 commitnum, const struct fee_states *fee_states, const struct changed_htlc *changed, const struct bitcoin_signature *commit_sig, const secp256k1_ecdsa_signature *htlc_sigs);
bool fromwire_channel_sending_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct fee_states **fee_states, struct changed_htlc **changed, struct bitcoin_signature *commit_sig, secp256k1_ecdsa_signature **htlc_sigs);

/* WIRE: CHANNEL_SENDING_COMMITSIG_REPLY */
/*  Wait for reply */
u8 *towire_channel_sending_commitsig_reply(const tal_t *ctx);
bool fromwire_channel_sending_commitsig_reply(const void *p);

/* WIRE: CHANNEL_GOT_COMMITSIG */
/*  When we have a commitment_signed message */
u8 *towire_channel_got_commitsig(const tal_t *ctx, u64 commitnum, const struct fee_states *fee_states, const struct bitcoin_signature *signature, const secp256k1_ecdsa_signature *htlc_signature, const struct added_htlc *added, const struct secret *shared_secret, const struct fulfilled_htlc *fulfilled, const struct failed_htlc **failed, const struct changed_htlc *changed, const struct bitcoin_tx *tx);
bool fromwire_channel_got_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct fee_states **fee_states, struct bitcoin_signature *signature, secp256k1_ecdsa_signature **htlc_signature, struct added_htlc **added, struct secret **shared_secret, struct fulfilled_htlc **fulfilled, struct failed_htlc ***failed, struct changed_htlc **changed, struct bitcoin_tx **tx);

/* WIRE: CHANNEL_GOT_COMMITSIG_REPLY */
/*  Wait for reply */
u8 *towire_channel_got_commitsig_reply(const tal_t *ctx);
bool fromwire_channel_got_commitsig_reply(const void *p);

/* WIRE: CHANNEL_GOT_REVOKE */
u8 *towire_channel_got_revoke(const tal_t *ctx, u64 revokenum, const struct secret *per_commitment_secret, const struct pubkey *next_per_commit_point, const struct fee_states *fee_states, const struct changed_htlc *changed);
bool fromwire_channel_got_revoke(const tal_t *ctx, const void *p, u64 *revokenum, struct secret *per_commitment_secret, struct pubkey *next_per_commit_point, struct fee_states **fee_states, struct changed_htlc **changed);

/* WIRE: CHANNEL_GOT_REVOKE_REPLY */
/*  Wait for reply */
/*  (eg. if we sent another commitment_signed */
u8 *towire_channel_got_revoke_reply(const tal_t *ctx);
bool fromwire_channel_got_revoke_reply(const void *p);

/* WIRE: CHANNEL_SEND_SHUTDOWN */
/*  Tell peer to shut down channel. */
u8 *towire_channel_send_shutdown(const tal_t *ctx, const u8 *shutdown_scriptpubkey);
bool fromwire_channel_send_shutdown(const tal_t *ctx, const void *p, u8 **shutdown_scriptpubkey);

/* WIRE: CHANNEL_GOT_SHUTDOWN */
/*  Peer told us that channel is shutting down */
u8 *towire_channel_got_shutdown(const tal_t *ctx, const u8 *scriptpubkey);
bool fromwire_channel_got_shutdown(const tal_t *ctx, const void *p, u8 **scriptpubkey);

/* WIRE: CHANNEL_SHUTDOWN_COMPLETE */
/*  Shutdown is complete */
u8 *towire_channel_shutdown_complete(const tal_t *ctx, const struct per_peer_state *per_peer_state);
bool fromwire_channel_shutdown_complete(const tal_t *ctx, const void *p, struct per_peer_state **per_peer_state);

/* WIRE: CHANNEL_DEV_REENABLE_COMMIT */
/*  Re-enable commit timer. */
u8 *towire_channel_dev_reenable_commit(const tal_t *ctx);
bool fromwire_channel_dev_reenable_commit(const void *p);

/* WIRE: CHANNEL_DEV_REENABLE_COMMIT_REPLY */
u8 *towire_channel_dev_reenable_commit_reply(const tal_t *ctx);
bool fromwire_channel_dev_reenable_commit_reply(const void *p);

/* WIRE: CHANNEL_FEERATES */
u8 *towire_channel_feerates(const tal_t *ctx, u32 feerate, u32 min_feerate, u32 max_feerate);
bool fromwire_channel_feerates(const void *p, u32 *feerate, u32 *min_feerate, u32 *max_feerate);

/* WIRE: CHANNEL_DEV_MEMLEAK */
/*  master -> channeld: do you have a memleak? */
u8 *towire_channel_dev_memleak(const tal_t *ctx);
bool fromwire_channel_dev_memleak(const void *p);

/* WIRE: CHANNEL_DEV_MEMLEAK_REPLY */
u8 *towire_channel_dev_memleak_reply(const tal_t *ctx, bool leak);
bool fromwire_channel_dev_memleak_reply(const void *p, bool *leak);

/* WIRE: CHANNEL_FAIL_FALLEN_BEHIND */
/*  Peer presented proof it was from the future. */
u8 *towire_channel_fail_fallen_behind(const tal_t *ctx, const struct pubkey *remote_per_commitment_point);
bool fromwire_channel_fail_fallen_behind(const tal_t *ctx, const void *p, struct pubkey **remote_per_commitment_point);

/* WIRE: CHANNEL_SPECIFIC_FEERATES */
/*  Handle a channel specific feerate base ppm configuration */
u8 *towire_channel_specific_feerates(const tal_t *ctx, u32 feerate_base, u32 feerate_ppm);
bool fromwire_channel_specific_feerates(const void *p, u32 *feerate_base, u32 *feerate_ppm);

/* WIRE: CHANNEL_GOT_ANNOUNCEMENT */
/*  When we receive announcement_signatures for channel announce */
u8 *towire_channel_got_announcement(const tal_t *ctx, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig);
bool fromwire_channel_got_announcement(const void *p, secp256k1_ecdsa_signature *remote_ann_node_sig, secp256k1_ecdsa_signature *remote_ann_bitcoin_sig);

/* WIRE: CHANNEL_SEND_ERROR */
/*  Ask channeld to send a error message. Used in forgetting channel case. */
u8 *towire_channel_send_error(const tal_t *ctx, const wirestring *reason);
bool fromwire_channel_send_error(const tal_t *ctx, const void *p, wirestring **reason);

/* WIRE: CHANNEL_SEND_ERROR_REPLY */
/*  Tell master channeld has sent the error message. */
u8 *towire_channel_send_error_reply(const tal_t *ctx);
bool fromwire_channel_send_error_reply(const void *p);


#endif /* LIGHTNING_CHANNELD_GEN_CHANNEL_WIRE_H */

