/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <hsmd/gen_hsm_wire.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *hsm_wire_type_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum hsm_wire_type)e) {
	case WIRE_HSM_CLIENT_HSMFD_REPLY: return "WIRE_HSM_CLIENT_HSMFD_REPLY";
	case WIRE_HSM_CUPDATE_SIG_REPLY: return "WIRE_HSM_CUPDATE_SIG_REPLY";
	case WIRE_HSM_GET_CHANNEL_BASEPOINTS: return "WIRE_HSM_GET_CHANNEL_BASEPOINTS";
	case WIRE_HSMSTATUS_CLIENT_BAD_REQUEST: return "WIRE_HSMSTATUS_CLIENT_BAD_REQUEST";
	case WIRE_HSM_SIGN_INVOICE: return "WIRE_HSM_SIGN_INVOICE";
	case WIRE_HSM_DEV_MEMLEAK: return "WIRE_HSM_DEV_MEMLEAK";
	case WIRE_HSM_SIGN_REMOTE_COMMITMENT_TX: return "WIRE_HSM_SIGN_REMOTE_COMMITMENT_TX";
	case WIRE_HSM_SIGN_MESSAGE_REPLY: return "WIRE_HSM_SIGN_MESSAGE_REPLY";
	case WIRE_HSM_GET_CHANNEL_BASEPOINTS_REPLY: return "WIRE_HSM_GET_CHANNEL_BASEPOINTS_REPLY";
	case WIRE_HSM_CUPDATE_SIG_REQ: return "WIRE_HSM_CUPDATE_SIG_REQ";
	case WIRE_HSM_SIGN_FUNDING_REPLY: return "WIRE_HSM_SIGN_FUNDING_REPLY";
	case WIRE_HSM_SIGN_REMOTE_HTLC_TO_US: return "WIRE_HSM_SIGN_REMOTE_HTLC_TO_US";
	case WIRE_HSM_CHECK_FUTURE_SECRET_REPLY: return "WIRE_HSM_CHECK_FUTURE_SECRET_REPLY";
	case WIRE_HSM_ECDH_RESP: return "WIRE_HSM_ECDH_RESP";
	case WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REPLY: return "WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REPLY";
	case WIRE_HSM_SIGN_LOCAL_HTLC_TX: return "WIRE_HSM_SIGN_LOCAL_HTLC_TX";
	case WIRE_HSM_ECDH_REQ: return "WIRE_HSM_ECDH_REQ";
	case WIRE_HSM_SIGN_INVOICE_REPLY: return "WIRE_HSM_SIGN_INVOICE_REPLY";
	case WIRE_HSM_SIGN_MUTUAL_CLOSE_TX: return "WIRE_HSM_SIGN_MUTUAL_CLOSE_TX";
	case WIRE_HSM_GET_PER_COMMITMENT_POINT_REPLY: return "WIRE_HSM_GET_PER_COMMITMENT_POINT_REPLY";
	case WIRE_HSM_SIGN_WITHDRAWAL_REPLY: return "WIRE_HSM_SIGN_WITHDRAWAL_REPLY";
	case WIRE_HSM_CANNOUNCEMENT_SIG_REQ: return "WIRE_HSM_CANNOUNCEMENT_SIG_REQ";
	case WIRE_HSM_INIT: return "WIRE_HSM_INIT";
	case WIRE_HSM_SIGN_PENALTY_TO_US: return "WIRE_HSM_SIGN_PENALTY_TO_US";
	case WIRE_HSM_CLIENT_HSMFD: return "WIRE_HSM_CLIENT_HSMFD";
	case WIRE_HSM_CANNOUNCEMENT_SIG_REPLY: return "WIRE_HSM_CANNOUNCEMENT_SIG_REPLY";
	case WIRE_HSM_SIGN_REMOTE_HTLC_TX: return "WIRE_HSM_SIGN_REMOTE_HTLC_TX";
	case WIRE_HSM_INIT_REPLY: return "WIRE_HSM_INIT_REPLY";
	case WIRE_HSM_SIGN_MESSAGE: return "WIRE_HSM_SIGN_MESSAGE";
	case WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REQ: return "WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REQ";
	case WIRE_HSM_SIGN_WITHDRAWAL: return "WIRE_HSM_SIGN_WITHDRAWAL";
	case WIRE_HSM_GET_PER_COMMITMENT_POINT: return "WIRE_HSM_GET_PER_COMMITMENT_POINT";
	case WIRE_HSM_SIGN_COMMITMENT_TX_REPLY: return "WIRE_HSM_SIGN_COMMITMENT_TX_REPLY";
	case WIRE_HSM_SIGN_TX_REPLY: return "WIRE_HSM_SIGN_TX_REPLY";
	case WIRE_HSM_SIGN_DELAYED_PAYMENT_TO_US: return "WIRE_HSM_SIGN_DELAYED_PAYMENT_TO_US";
	case WIRE_HSM_SIGN_COMMITMENT_TX: return "WIRE_HSM_SIGN_COMMITMENT_TX";
	case WIRE_HSM_SIGN_FUNDING: return "WIRE_HSM_SIGN_FUNDING";
	case WIRE_HSM_CHECK_FUTURE_SECRET: return "WIRE_HSM_CHECK_FUTURE_SECRET";
	case WIRE_HSM_DEV_MEMLEAK_REPLY: return "WIRE_HSM_DEV_MEMLEAK_REPLY";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}




/* WIRE: HSM_CLIENT_HSMFD_REPLY */
/* No content */
u8 *towire_hsm_client_hsmfd_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CLIENT_HSMFD_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_client_hsmfd_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CLIENT_HSMFD_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: HSM_CUPDATE_SIG_REPLY */
u8 *towire_hsm_cupdate_sig_reply(const tal_t *ctx, const u8 *cu)
{
	u16 culen = tal_count(cu);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CUPDATE_SIG_REPLY);
	towire_u16(&p, culen);
	towire_u8_array(&p, cu, culen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_cupdate_sig_reply(const tal_t *ctx, const void *p, u8 **cu)
{
	u16 culen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CUPDATE_SIG_REPLY)
		return false;
 	culen = fromwire_u16(&cursor, &plen);
 	// 2nd case cu
	*cu = culen ? tal_arr(ctx, u8, culen) : NULL;
	fromwire_u8_array(&cursor, &plen, *cu, culen);
	return cursor != NULL;
}

/* WIRE: HSM_GET_CHANNEL_BASEPOINTS */
/* Get the basepoints and funding key for this specific channel. */
u8 *towire_hsm_get_channel_basepoints(const tal_t *ctx, const struct node_id *peerid, u64 dbid)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_GET_CHANNEL_BASEPOINTS);
	towire_node_id(&p, peerid);
	towire_u64(&p, dbid);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_get_channel_basepoints(const void *p, struct node_id *peerid, u64 *dbid)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_GET_CHANNEL_BASEPOINTS)
		return false;
 	fromwire_node_id(&cursor, &plen, peerid);
 	*dbid = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMSTATUS_CLIENT_BAD_REQUEST */
/* Clients should not give a bad request but not the HSM's decision to crash. */
u8 *towire_hsmstatus_client_bad_request(const tal_t *ctx, const struct node_id *id, const wirestring *description, const u8 *msg)
{
	u16 len = tal_count(msg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMSTATUS_CLIENT_BAD_REQUEST);
	towire_node_id(&p, id);
	towire_wirestring(&p, description);
	towire_u16(&p, len);
	towire_u8_array(&p, msg, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmstatus_client_bad_request(const tal_t *ctx, const void *p, struct node_id *id, wirestring **description, u8 **msg)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMSTATUS_CLIENT_BAD_REQUEST)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
 	*description = fromwire_wirestring(ctx, &cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case msg
	*msg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *msg, len);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_INVOICE */
/* Sign an invoice */
u8 *towire_hsm_sign_invoice(const tal_t *ctx, const u8 *u5bytes, const u8 *hrp)
{
	u16 len = tal_count(u5bytes);
	u16 hrplen = tal_count(hrp);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_INVOICE);
	towire_u16(&p, len);
	towire_u8_array(&p, u5bytes, len);
	towire_u16(&p, hrplen);
	towire_u8_array(&p, hrp, hrplen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_invoice(const tal_t *ctx, const void *p, u8 **u5bytes, u8 **hrp)
{
	u16 len;
	u16 hrplen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_INVOICE)
		return false;
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case u5bytes
	*u5bytes = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *u5bytes, len);
 	hrplen = fromwire_u16(&cursor, &plen);
 	// 2nd case hrp
	*hrp = hrplen ? tal_arr(ctx, u8, hrplen) : NULL;
	fromwire_u8_array(&cursor, &plen, *hrp, hrplen);
	return cursor != NULL;
}

/* WIRE: HSM_DEV_MEMLEAK */
/* master -> hsmd: do you have a memleak? */
u8 *towire_hsm_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_REMOTE_COMMITMENT_TX */
/* Openingd/channeld asks HSM to sign the other sides' commitment tx. */
u8 *towire_hsm_sign_remote_commitment_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key, struct amount_sat funding_amount)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_REMOTE_COMMITMENT_TX);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);
	towire_amount_sat(&p, funding_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_remote_commitment_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, struct pubkey *remote_funding_key, struct amount_sat *funding_amount)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_REMOTE_COMMITMENT_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
 	*funding_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_MESSAGE_REPLY */
u8 *towire_hsm_sign_message_reply(const tal_t *ctx, const secp256k1_ecdsa_recoverable_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_MESSAGE_REPLY);
	towire_secp256k1_ecdsa_recoverable_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_message_reply(const void *p, secp256k1_ecdsa_recoverable_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_MESSAGE_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_recoverable_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSM_GET_CHANNEL_BASEPOINTS_REPLY */
u8 *towire_hsm_get_channel_basepoints_reply(const tal_t *ctx, const struct basepoints *basepoints, const struct pubkey *funding_pubkey)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_GET_CHANNEL_BASEPOINTS_REPLY);
	towire_basepoints(&p, basepoints);
	towire_pubkey(&p, funding_pubkey);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_get_channel_basepoints_reply(const void *p, struct basepoints *basepoints, struct pubkey *funding_pubkey)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_GET_CHANNEL_BASEPOINTS_REPLY)
		return false;
 	fromwire_basepoints(&cursor, &plen, basepoints);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
	return cursor != NULL;
}

/* WIRE: HSM_CUPDATE_SIG_REQ */
u8 *towire_hsm_cupdate_sig_req(const tal_t *ctx, const u8 *cu)
{
	u16 culen = tal_count(cu);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CUPDATE_SIG_REQ);
	towire_u16(&p, culen);
	towire_u8_array(&p, cu, culen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_cupdate_sig_req(const tal_t *ctx, const void *p, u8 **cu)
{
	u16 culen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CUPDATE_SIG_REQ)
		return false;
 	culen = fromwire_u16(&cursor, &plen);
 	// 2nd case cu
	*cu = culen ? tal_arr(ctx, u8, culen) : NULL;
	fromwire_u8_array(&cursor, &plen, *cu, culen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_FUNDING_REPLY */
u8 *towire_hsm_sign_funding_reply(const tal_t *ctx, const struct bitcoin_tx *tx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_FUNDING_REPLY);
	towire_bitcoin_tx(&p, tx);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_funding_reply(const tal_t *ctx, const void *p, struct bitcoin_tx **tx)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_FUNDING_REPLY)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_REMOTE_HTLC_TO_US */
u8 *towire_hsm_sign_remote_htlc_to_us(const tal_t *ctx, const struct pubkey *remote_per_commitment_point, const struct bitcoin_tx *tx, const u8 *wscript, struct amount_sat input_amount)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_REMOTE_HTLC_TO_US);
	towire_pubkey(&p, remote_per_commitment_point);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_amount_sat(&p, input_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_remote_htlc_to_us(const tal_t *ctx, const void *p, struct pubkey *remote_per_commitment_point, struct bitcoin_tx **tx, u8 **wscript, struct amount_sat *input_amount)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_REMOTE_HTLC_TO_US)
		return false;
 	fromwire_pubkey(&cursor, &plen, remote_per_commitment_point);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*input_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_CHECK_FUTURE_SECRET_REPLY */
u8 *towire_hsm_check_future_secret_reply(const tal_t *ctx, bool correct)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CHECK_FUTURE_SECRET_REPLY);
	towire_bool(&p, correct);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_check_future_secret_reply(const void *p, bool *correct)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CHECK_FUTURE_SECRET_REPLY)
		return false;
 	*correct = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_ECDH_RESP */
u8 *towire_hsm_ecdh_resp(const tal_t *ctx, const struct secret *ss)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_ECDH_RESP);
	towire_secret(&p, ss);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_ecdh_resp(const void *p, struct secret *ss)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_ECDH_RESP)
		return false;
 	fromwire_secret(&cursor, &plen, ss);
	return cursor != NULL;
}

/* WIRE: HSM_NODE_ANNOUNCEMENT_SIG_REPLY */
u8 *towire_hsm_node_announcement_sig_reply(const tal_t *ctx, const secp256k1_ecdsa_signature *signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REPLY);
	towire_secp256k1_ecdsa_signature(&p, signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_node_announcement_sig_reply(const void *p, secp256k1_ecdsa_signature *signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_LOCAL_HTLC_TX */
/* Onchaind asks HSM to sign a local HTLC success or HTLC timeout tx. */
u8 *towire_hsm_sign_local_htlc_tx(const tal_t *ctx, u64 commit_num, const struct bitcoin_tx *tx, const u8 *wscript, struct amount_sat input_amount)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_LOCAL_HTLC_TX);
	towire_u64(&p, commit_num);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_amount_sat(&p, input_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_local_htlc_tx(const tal_t *ctx, const void *p, u64 *commit_num, struct bitcoin_tx **tx, u8 **wscript, struct amount_sat *input_amount)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_LOCAL_HTLC_TX)
		return false;
 	*commit_num = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*input_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_ECDH_REQ */
/* Give me ECDH(node-id-secret */
u8 *towire_hsm_ecdh_req(const tal_t *ctx, const struct pubkey *point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_ECDH_REQ);
	towire_pubkey(&p, point);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_ecdh_req(const void *p, struct pubkey *point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_ECDH_REQ)
		return false;
 	fromwire_pubkey(&cursor, &plen, point);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_INVOICE_REPLY */
u8 *towire_hsm_sign_invoice_reply(const tal_t *ctx, const secp256k1_ecdsa_recoverable_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_INVOICE_REPLY);
	towire_secp256k1_ecdsa_recoverable_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_invoice_reply(const void *p, secp256k1_ecdsa_recoverable_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_INVOICE_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_recoverable_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_MUTUAL_CLOSE_TX */
/* closingd asks HSM to sign mutual close tx. */
u8 *towire_hsm_sign_mutual_close_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key, struct amount_sat funding)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_MUTUAL_CLOSE_TX);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);
	towire_amount_sat(&p, funding);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_mutual_close_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, struct pubkey *remote_funding_key, struct amount_sat *funding)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_MUTUAL_CLOSE_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
 	*funding = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_GET_PER_COMMITMENT_POINT_REPLY */
u8 *towire_hsm_get_per_commitment_point_reply(const tal_t *ctx, const struct pubkey *per_commitment_point, const struct secret *old_commitment_secret)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_GET_PER_COMMITMENT_POINT_REPLY);
	towire_pubkey(&p, per_commitment_point);
	if (!old_commitment_secret)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, old_commitment_secret);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_get_per_commitment_point_reply(const tal_t *ctx, const void *p, struct pubkey *per_commitment_point, struct secret **old_commitment_secret)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_GET_PER_COMMITMENT_POINT_REPLY)
		return false;
 	fromwire_pubkey(&cursor, &plen, per_commitment_point);
 	if (!fromwire_bool(&cursor, &plen))
		*old_commitment_secret = NULL;
	else {
		*old_commitment_secret = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *old_commitment_secret);
	}
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_WITHDRAWAL_REPLY */
u8 *towire_hsm_sign_withdrawal_reply(const tal_t *ctx, const struct bitcoin_tx *tx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_WITHDRAWAL_REPLY);
	towire_bitcoin_tx(&p, tx);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_withdrawal_reply(const tal_t *ctx, const void *p, struct bitcoin_tx **tx)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_WITHDRAWAL_REPLY)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_CANNOUNCEMENT_SIG_REQ */
u8 *towire_hsm_cannouncement_sig_req(const tal_t *ctx, const u8 *ca)
{
	u16 calen = tal_count(ca);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CANNOUNCEMENT_SIG_REQ);
	towire_u16(&p, calen);
	towire_u8_array(&p, ca, calen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_cannouncement_sig_req(const tal_t *ctx, const void *p, u8 **ca)
{
	u16 calen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CANNOUNCEMENT_SIG_REQ)
		return false;
 	calen = fromwire_u16(&cursor, &plen);
 	// 2nd case ca
	*ca = calen ? tal_arr(ctx, u8, calen) : NULL;
	fromwire_u8_array(&cursor, &plen, *ca, calen);
	return cursor != NULL;
}

/* WIRE: HSM_INIT */
/* Start the HSM. */
u8 *towire_hsm_init(const tal_t *ctx, const struct bip32_key_version *bip32_key_version, const struct chainparams *chainparams, const struct secret *hsm_encryption_key, const struct privkey *dev_force_privkey, const struct secret *dev_force_bip32_seed, const struct secrets *dev_force_channel_secrets, const struct sha256 *dev_force_channel_secrets_shaseed)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_INIT);
	towire_bip32_key_version(&p, bip32_key_version);
	towire_chainparams(&p, chainparams);
	if (!hsm_encryption_key)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, hsm_encryption_key);
	}
	if (!dev_force_privkey)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_privkey(&p, dev_force_privkey);
	}
	if (!dev_force_bip32_seed)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, dev_force_bip32_seed);
	}
	if (!dev_force_channel_secrets)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secrets(&p, dev_force_channel_secrets);
	}
	if (!dev_force_channel_secrets_shaseed)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_sha256(&p, dev_force_channel_secrets_shaseed);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_init(const tal_t *ctx, const void *p, struct bip32_key_version *bip32_key_version, const struct chainparams **chainparams, struct secret **hsm_encryption_key, struct privkey **dev_force_privkey, struct secret **dev_force_bip32_seed, struct secrets **dev_force_channel_secrets, struct sha256 **dev_force_channel_secrets_shaseed)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_INIT)
		return false;
 	fromwire_bip32_key_version(&cursor, &plen, bip32_key_version);
 	fromwire_chainparams(&cursor, &plen, chainparams);
 	if (!fromwire_bool(&cursor, &plen))
		*hsm_encryption_key = NULL;
	else {
		*hsm_encryption_key = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *hsm_encryption_key);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_privkey = NULL;
	else {
		*dev_force_privkey = tal(ctx, struct privkey);
		fromwire_privkey(&cursor, &plen, *dev_force_privkey);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_bip32_seed = NULL;
	else {
		*dev_force_bip32_seed = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *dev_force_bip32_seed);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_channel_secrets = NULL;
	else {
		*dev_force_channel_secrets = tal(ctx, struct secrets);
		fromwire_secrets(&cursor, &plen, *dev_force_channel_secrets);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_channel_secrets_shaseed = NULL;
	else {
		*dev_force_channel_secrets_shaseed = tal(ctx, struct sha256);
		fromwire_sha256(&cursor, &plen, *dev_force_channel_secrets_shaseed);
	}
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_PENALTY_TO_US */
u8 *towire_hsm_sign_penalty_to_us(const tal_t *ctx, const struct secret *revocation_secret, const struct bitcoin_tx *tx, const u8 *wscript, struct amount_sat input_amount)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_PENALTY_TO_US);
	towire_secret(&p, revocation_secret);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_amount_sat(&p, input_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_penalty_to_us(const tal_t *ctx, const void *p, struct secret *revocation_secret, struct bitcoin_tx **tx, u8 **wscript, struct amount_sat *input_amount)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_PENALTY_TO_US)
		return false;
 	fromwire_secret(&cursor, &plen, revocation_secret);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*input_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_CLIENT_HSMFD */
/* Get a new HSM FD */
u8 *towire_hsm_client_hsmfd(const tal_t *ctx, const struct node_id *id, u64 dbid, u64 capabilities)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CLIENT_HSMFD);
	/* Which identity to use for requests */
	towire_node_id(&p, id);
	/* Database id for this client */
	towire_u64(&p, dbid);
	towire_u64(&p, capabilities);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_client_hsmfd(const void *p, struct node_id *id, u64 *dbid, u64 *capabilities)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CLIENT_HSMFD)
		return false;
 	/* Which identity to use for requests */
	fromwire_node_id(&cursor, &plen, id);
 	/* Database id for this client */
	*dbid = fromwire_u64(&cursor, &plen);
 	*capabilities = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_CANNOUNCEMENT_SIG_REPLY */
u8 *towire_hsm_cannouncement_sig_reply(const tal_t *ctx, const secp256k1_ecdsa_signature *node_signature, const secp256k1_ecdsa_signature *bitcoin_signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CANNOUNCEMENT_SIG_REPLY);
	towire_secp256k1_ecdsa_signature(&p, node_signature);
	towire_secp256k1_ecdsa_signature(&p, bitcoin_signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_cannouncement_sig_reply(const void *p, secp256k1_ecdsa_signature *node_signature, secp256k1_ecdsa_signature *bitcoin_signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CANNOUNCEMENT_SIG_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, node_signature);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, bitcoin_signature);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_REMOTE_HTLC_TX */
/* channeld asks HSM to sign remote HTLC tx. */
u8 *towire_hsm_sign_remote_htlc_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const u8 *wscript, struct amount_sat amounts_satoshi, const struct pubkey *remote_per_commit_point)
{
	u16 len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_REMOTE_HTLC_TX);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, len);
	towire_u8_array(&p, wscript, len);
	towire_amount_sat(&p, amounts_satoshi);
	towire_pubkey(&p, remote_per_commit_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_remote_htlc_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, u8 **wscript, struct amount_sat *amounts_satoshi, struct pubkey *remote_per_commit_point)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_REMOTE_HTLC_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, len);
 	*amounts_satoshi = fromwire_amount_sat(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_per_commit_point);
	return cursor != NULL;
}

/* WIRE: HSM_INIT_REPLY */
u8 *towire_hsm_init_reply(const tal_t *ctx, const struct node_id *node_id, const struct ext_key *bip32)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_INIT_REPLY);
	towire_node_id(&p, node_id);
	towire_ext_key(&p, bip32);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_init_reply(const void *p, struct node_id *node_id, struct ext_key *bip32)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_INIT_REPLY)
		return false;
 	fromwire_node_id(&cursor, &plen, node_id);
 	fromwire_ext_key(&cursor, &plen, bip32);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_MESSAGE */
/* lightningd asks us to sign a string. */
u8 *towire_hsm_sign_message(const tal_t *ctx, const u8 *msg)
{
	u16 len = tal_count(msg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_MESSAGE);
	towire_u16(&p, len);
	towire_u8_array(&p, msg, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_message(const tal_t *ctx, const void *p, u8 **msg)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_MESSAGE)
		return false;
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case msg
	*msg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *msg, len);
	return cursor != NULL;
}

/* WIRE: HSM_NODE_ANNOUNCEMENT_SIG_REQ */
/* Master asks the HSM to sign a node_announcement */
u8 *towire_hsm_node_announcement_sig_req(const tal_t *ctx, const u8 *announcement)
{
	u16 annlen = tal_count(announcement);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REQ);
	towire_u16(&p, annlen);
	towire_u8_array(&p, announcement, annlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_node_announcement_sig_req(const tal_t *ctx, const void *p, u8 **announcement)
{
	u16 annlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_NODE_ANNOUNCEMENT_SIG_REQ)
		return false;
 	annlen = fromwire_u16(&cursor, &plen);
 	// 2nd case announcement
	*announcement = annlen ? tal_arr(ctx, u8, annlen) : NULL;
	fromwire_u8_array(&cursor, &plen, *announcement, annlen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_WITHDRAWAL */
/* Sign a withdrawal request */
u8 *towire_hsm_sign_withdrawal(const tal_t *ctx, struct amount_sat satoshi_out, struct amount_sat change_out, u32 change_keyindex, const struct bitcoin_tx_output **outputs, const struct utxo **inputs)
{
	u16 num_outputs = tal_count(outputs);
	u16 num_inputs = tal_count(inputs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_WITHDRAWAL);
	towire_amount_sat(&p, satoshi_out);
	towire_amount_sat(&p, change_out);
	towire_u32(&p, change_keyindex);
	towire_u16(&p, num_outputs);
	for (size_t i = 0; i < num_outputs; i++)
		towire_bitcoin_tx_output(&p, outputs[i]);
	towire_u16(&p, num_inputs);
	for (size_t i = 0; i < num_inputs; i++)
		towire_utxo(&p, inputs[i]);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_withdrawal(const tal_t *ctx, const void *p, struct amount_sat *satoshi_out, struct amount_sat *change_out, u32 *change_keyindex, struct bitcoin_tx_output ***outputs, struct utxo ***inputs)
{
	u16 num_outputs;
	u16 num_inputs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_WITHDRAWAL)
		return false;
 	*satoshi_out = fromwire_amount_sat(&cursor, &plen);
 	*change_out = fromwire_amount_sat(&cursor, &plen);
 	*change_keyindex = fromwire_u32(&cursor, &plen);
 	num_outputs = fromwire_u16(&cursor, &plen);
 	// 2nd case outputs
	*outputs = num_outputs ? tal_arr(ctx, struct bitcoin_tx_output *, num_outputs) : NULL;
	for (size_t i = 0; i < num_outputs; i++)
		(*outputs)[i] = fromwire_bitcoin_tx_output(*outputs, &cursor, &plen);
 	num_inputs = fromwire_u16(&cursor, &plen);
 	// 2nd case inputs
	*inputs = num_inputs ? tal_arr(ctx, struct utxo *, num_inputs) : NULL;
	for (size_t i = 0; i < num_inputs; i++)
		(*inputs)[i] = fromwire_utxo(*inputs, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_GET_PER_COMMITMENT_POINT */
/* Openingd/channeld/onchaind asks for Nth per_commitment_point */
u8 *towire_hsm_get_per_commitment_point(const tal_t *ctx, u64 n)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_GET_PER_COMMITMENT_POINT);
	towire_u64(&p, n);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_get_per_commitment_point(const void *p, u64 *n)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_GET_PER_COMMITMENT_POINT)
		return false;
 	*n = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_COMMITMENT_TX_REPLY */
u8 *towire_hsm_sign_commitment_tx_reply(const tal_t *ctx, const struct bitcoin_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_COMMITMENT_TX_REPLY);
	towire_bitcoin_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_commitment_tx_reply(const void *p, struct bitcoin_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_COMMITMENT_TX_REPLY)
		return false;
 	fromwire_bitcoin_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_TX_REPLY */
/* Reply for all the above requests. */
u8 *towire_hsm_sign_tx_reply(const tal_t *ctx, const struct bitcoin_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_TX_REPLY);
	towire_bitcoin_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_tx_reply(const void *p, struct bitcoin_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_TX_REPLY)
		return false;
 	fromwire_bitcoin_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_DELAYED_PAYMENT_TO_US */
/* Onchaind asks HSM to sign a spend to-us.  Four variants */
/* of keys is derived differently... */
/* FIXME: Have master tell hsmd the keyindex */
u8 *towire_hsm_sign_delayed_payment_to_us(const tal_t *ctx, u64 commit_num, const struct bitcoin_tx *tx, const u8 *wscript, struct amount_sat input_amount)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_DELAYED_PAYMENT_TO_US);
	towire_u64(&p, commit_num);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_amount_sat(&p, input_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_delayed_payment_to_us(const tal_t *ctx, const void *p, u64 *commit_num, struct bitcoin_tx **tx, u8 **wscript, struct amount_sat *input_amount)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_DELAYED_PAYMENT_TO_US)
		return false;
 	*commit_num = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*input_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_COMMITMENT_TX */
/* Master asks HSM to sign a commitment transaction. */
u8 *towire_hsm_sign_commitment_tx(const tal_t *ctx, const struct node_id *peer_id, u64 channel_dbid, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key, struct amount_sat funding_amount)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_COMMITMENT_TX);
	towire_node_id(&p, peer_id);
	towire_u64(&p, channel_dbid);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);
	towire_amount_sat(&p, funding_amount);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_commitment_tx(const tal_t *ctx, const void *p, struct node_id *peer_id, u64 *channel_dbid, struct bitcoin_tx **tx, struct pubkey *remote_funding_key, struct amount_sat *funding_amount)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_COMMITMENT_TX)
		return false;
 	fromwire_node_id(&cursor, &plen, peer_id);
 	*channel_dbid = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
 	*funding_amount = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_SIGN_FUNDING */
/* Return signature for a funding tx. */
/* FIXME: This should also take their commit sig & details */
u8 *towire_hsm_sign_funding(const tal_t *ctx, struct amount_sat satoshi_out, struct amount_sat change_out, u32 change_keyindex, const struct pubkey *our_pubkey, const struct pubkey *their_pubkey, const struct utxo **inputs)
{
	u16 num_inputs = tal_count(inputs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_SIGN_FUNDING);
	towire_amount_sat(&p, satoshi_out);
	towire_amount_sat(&p, change_out);
	towire_u32(&p, change_keyindex);
	towire_pubkey(&p, our_pubkey);
	towire_pubkey(&p, their_pubkey);
	towire_u16(&p, num_inputs);
	for (size_t i = 0; i < num_inputs; i++)
		towire_utxo(&p, inputs[i]);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_sign_funding(const tal_t *ctx, const void *p, struct amount_sat *satoshi_out, struct amount_sat *change_out, u32 *change_keyindex, struct pubkey *our_pubkey, struct pubkey *their_pubkey, struct utxo ***inputs)
{
	u16 num_inputs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_SIGN_FUNDING)
		return false;
 	*satoshi_out = fromwire_amount_sat(&cursor, &plen);
 	*change_out = fromwire_amount_sat(&cursor, &plen);
 	*change_keyindex = fromwire_u32(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, our_pubkey);
 	fromwire_pubkey(&cursor, &plen, their_pubkey);
 	num_inputs = fromwire_u16(&cursor, &plen);
 	// 2nd case inputs
	*inputs = num_inputs ? tal_arr(ctx, struct utxo *, num_inputs) : NULL;
	for (size_t i = 0; i < num_inputs; i++)
		(*inputs)[i] = fromwire_utxo(*inputs, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSM_CHECK_FUTURE_SECRET */
/* channeld asks to check if claimed future commitment_secret is correct. */
u8 *towire_hsm_check_future_secret(const tal_t *ctx, u64 n, const struct secret *commitment_secret)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_CHECK_FUTURE_SECRET);
	towire_u64(&p, n);
	towire_secret(&p, commitment_secret);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_check_future_secret(const void *p, u64 *n, struct secret *commitment_secret)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_CHECK_FUTURE_SECRET)
		return false;
 	*n = fromwire_u64(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, commitment_secret);
	return cursor != NULL;
}

/* WIRE: HSM_DEV_MEMLEAK_REPLY */
u8 *towire_hsm_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSM_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsm_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSM_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

